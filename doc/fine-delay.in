\input texinfo    @c -*-texinfo-*-
%
% fine-delay.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month September 2012
@c @set release 1.1
@set tagname fine-delay-sw-v1.1
@c WARNING: in @example I Can't use @value{tagname}, so please look for this
@c string when updating the document.

@finalout

@titlepage
@title Fine Delay User's Manual
@subtitle @value{update-month}
@subtitle FMC Delay 1ns-4cha hardware and software manual
@author CERN BE-CO-HT / Tomasz Wlostowski, Alessandro Rubini
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual for the
``fmc-delay-1ns-4cha'' board developed on @code{ohwr.org}.  Please
note that the ohwr project is misnamed as @code{fmc-delay-1ns-8cha};
thus the web references include this wrong naming and it's not a typo
in the documentation.

@menu
* Repositories and Releases::   
* Hardware Description::        
* Driver Features::             
* Installation::                
* Source Code Conventions::     
* Using the Driver Directly::   
* Using the Provided API::      
* Calibration::                 
* Known Bugs and Missing Features::  
* Troubleshooting::             
@end menu

@c ##########################################################################
@node Repositories and Releases
@chapter Repositories and Releases

The code and documentation is distributed in the following places:

@table @code

@item http://www.ohwr.org/projects/fine-delay-sw/documents

	This place hosts the pdf documentation for every official
        release.

@item http://www.ohwr.org/projects/fine-delay-sw/files

	Here we place the @i{.tar.gz} file for every release,
        including the @i{git} tree and compiled documentation (for
        those who lack TeX).

@item git://ohwr.org/fmc-projects/fmc-delay-1ns-8cha/fine-delay-sw.git
@itemx git://gitorious.org/fine-delay/fine-delay.git

	Read-only repositories for the software and documentation.
        The former is authoritative, the latter is a backup.

@item git@@ohwr.org:fmc-projects/fmc-delay-1ns-8cha/fine-delay-sw.git
@itemx git@@gitorious.org:fine-delay/fine-delay.git

	Read-write repositories, for those authorized. Again, OHWR is
        the authoritative place, but we tend to push to gitorious as
        well.

@end table

The official release of this
repository has a tag called called
@code{@value{tagname}}. The same tag is used in related
repositories (@i{zio}, @i{spec-sw} and the hardware repository).
Any official hot fixes, if any,  for this
release live in the branch called
@code{@value{tagname}-fixes}, in each repository.

@b{Note:} If you got this from the repository (as opposed to a named
@i{tar.gz} or @i{pdf} file) it may happen that you are looking at a later commit
than the tagged release: it is a fact of life that developers forget
to re-read and fix documentation while updating the code. In that case,
please run ``@code{git describe HEAD}'' to ensure where you are.

@c ##########################################################################
@node Hardware Description
@chapter Hardware Description

The @i{FMC Delay 1ns-4cha} is an FPGA Mezzanine Card (FMC - VITA 57 standard),
whose main purpose is to produce pulses delayed by a user-programmed value with
respect to the input trigger pulse. The card can also work as a Time to Digital converter (TDC)
or as a programmable pulse generator triggering at a given TAI time. 

 For the sake of clarity of this document, the card's 
name will be further abbreviated as @i{FmcDelay}.

@menu
* Requirements and Supported Platforms::  
* Modes of Operation::          
* Mechanical/Environmental::    
* Electrical::                  
* Timing::                      
* Principles of Operation::     
@end menu

@c ==========================================================================
@node Requirements and Supported Platforms
@section Requirements and Supported Platforms

@i{FmcDelay} can work with any VITA 57-compliant FMC carrier, provided that the carrier's FPGA has enough logic resources. 
So far, FmcDelay has been only tested with the CERN's SPEC (Simple PCI-Express Carrier) board and the provided drivers currently
work only with that carrier. A VME version using the SVEC carrier is currently being developed and should be available soon.

In order to operate @i{FmcDelay}, the following hardware/software components are required:

@itemize @bullet
@item A standard PC with at least one free 4x (or wider) PCI-Express slot,
@item A SPEC PCI-Express FMC carrier (supplied with the @i{FmcDelay}),
@item 50-ohm cables with 1-pin LEMO 00 plugs for connecting the I/O signals,
@item Any Linux (kernel 2.6 or 3.0+) distribution,
@end itemize

@c ==========================================================================
@node Modes of Operation
@section Modes of Operation

@i{FmcDelay} can work in one or more of the following modes:
@itemize @bullet
@item @b{Pulse Delay}: produces one or more pulse(s) on selected outputs
a given time after an input trigger pulse (fig. 1a)
@item @b{Pulse Generator}: produces one or more pulse(s) on selected outputs starting at an
absolute time value programmed by the user (fig. 1b). In this mode, time base is usually provided by the White Rabbit network.
@item @b{Time to Digital Converter}: tags all trigger pulses and delivers the timestamps to the user's application.
@end itemize

@float
@image{drawings/func, 12cm,,,pdf}
@caption{Fig. 1. @i{FmcDelay} operating modes.}
@end float


Modes (pulse delay/generator) can be selected independently for each output. For example, one can configure the output 1 to delay trigger pulses
by 1 us, and the output 2 to produce a pulse at the beginning of each second. The TDC mode can be enabled for the input at any time and
does not interfere with the operation of the channels being time tagged.

@c ==========================================================================
@node Mechanical/Environmental
@section Mechanical/Environmental

@noindent @b{Mechanical and environmental specs:}
@itemize @bullet
@item Format: FMC (VITA 57), with rear zone for conduction cooling
@item Operating temperature range: 0 - 90 degC.
@item Carrier connection: 160-pin Low Pin Count FMC connector
@end itemize

@c ==========================================================================
@node Electrical
@section Electrical

@noindent @b{Inputs/Outputs:}
@itemize @bullet
@item 1 trigger input (LEMO 00)
@item 4 pulse outputs (LEMO 00)
@item 2 LEDs
@item Carrier communication via 160-pin Low Pin Count FMC connector
@end itemize

@noindent @b{Trigger input:}
@itemize
@item TTL/LVTTL levels, DC-coupled. Reception of a trigger pulse is indicated by blinking the "TRIG" LED in the front panel.
@item 2 kOhm or 50 Ohm input impedance (programmable via software). 50 Ohm termination is indicated by the "TERM" LED in the front panel.
@item Power-up input impedance: 2 kOhm.
@item Protected against short circuit, overcurrent (> 200 mA) and overvoltage (up to +28 V).
@item Maximum input pulse edge rise time: 20 ns.
@end itemize

@noindent @b{Outputs:}
@itemize
@item TTL-compatible levels DC-coupled: Voh = 3 V, Vol = 200 mV (50 Ohm load), Voh = 6 V, Vol = 400 mV (high impedance).
@item Output impedance: 50 Ohm (source-terminated)
@item Rise/fall time: 2.5 ns (10%% - 90%%, 50 Ohm load)
@item Power-up state: LOW (2 kOhm pulldown), guaranteed glitch-free.
@item Protected against continuous short circuit, overcurrent and overvoltage (up to +28 V).
@end itemize

@noindent @b{Power supply:}
@itemize
@item Used power supplies: P12V0, P3V3, P3V3_AUX, VADJ (voltage monitor only).
@item Typical current consumption: 200 mA (P12V0) + 1.5 A (P3V3).
@item Power dissipation: 7 W. Forced cooling is required.
@end itemize

@c ==========================================================================
@node Timing
@section Timing

@float
@image{drawings/io_timing, 14cm,,,pdf}
@caption{Fig. 2. @i{FmcDelay} timing parameter definitions.}
@end float

@noindent @b{Time base:}
@itemize @bullet
@item On-board oscillator accuracy: +/- 2.5 ppm (i.e. max. 2.5 ns error for a delay of 1 ms).
@item When using White Rabbit as the timing reference: depending on the characteristics of the grandmaster clock and the carrier used. On SPEC v 4.0 FMC carrier, the accuracy is better than 1 ns.
@end itemize

@noindent @b{Input timing:}
@itemize @bullet
@item Minimum pulse width: @math{t_{IW}} = 50 ns. Pulses below 24 ns are rejected.
@item Minimum gap between the last delayed output pulse and subsequent trigger pulse: @math{T_{LT}} = 50 ns
@item Input TDC performance: 400 ps pp accuracy, 27 ps resolution, 70 ps trigger-to-trigger rms jitter (measured at 500 kHz pulse rate)
@end itemize

@noindent @b{Output timing:}
@itemize @bullet
@item Resolution: 10 ps.
@item Accuracy (pulse generator mode): 300 ps.
@item Train generation: trains of 1-65536 pulses or continuous square wave up to 10 MHz.
@item Output-to-output jitter (outputs programmed to the same delay): 10 ps rms.
@item Output-to-output jitter (outputs programmed to to different delays, worst case): 30 ps rms.
@item Output pulse spacing (@math{T_{SP}}) : 100 ns - 16 s. Adjustable in 10 ps steps when both @math{T_{PW}}, @math{T_{GAP}} > 200 ns. Outside that range, @math{T_{SP}} resolution is limited to 4 ns.
@item Output pulse start (@math{t_{START}}) resolution: 10 ps for the rising edge of the pulse, 10 ps for subsequent pulses if the condition above is met, otherwise 4 ns.
@end itemize

@noindent @b{Delay mode specific parameters:}
@itemize @bullet
@item Delay accuracy: < 1 ns.
@item Trigger-to-output jitter: 80 ps rms.
@item Trigger-to-output delay: minimum @math{T_{DLY}} = 500 ns, maximum @math{T_{DLY}} = 120 s.
@item Maximum trigger pulse rate: @math{T_{DLY} + N*(T_{SP} + T_{GAP}) +} 100 ns, where N = number of output pulses. 
@item Trigger pulses are ignored until the output with the biggest delay has finished generation of the pulse(s).
@end itemize


@c ==========================================================================
@node Principles of Operation
@section Principles of Operation

@b{Note:} If you are an electronics engineer, you can skip this section, as you will most likely find it rather boring.

@float
@image{drawings/analog_digital_delays, 16cm,,,pdf}
@caption{Fig. 3. Principle of operation of analog and digital delay generators.}
@end float

Contrary to typical analog delay cards, which work by comparing an analog ramp triggered by the input pulse with a voltage proportional to the desired delay, 
@i{FmcDelay} is a digital delay generator, which relies on time tag arithmetic. The principle of operation of both generators is illustrated in figure 3.

When a trigger pulse comes to the input, @i{FmcDelay} first produces its' precise time tag using a Time-to-Digital converter (TDC). Afterwards, the time tag is summed together 
with the delay preset and the result is passed to a digital pulse generator. In its simplest form, it consists of a free running counter and a comparator. When the counter 
reaches the value provided on the input, a pulse is produced on the output. Note that in order for the system to work correctly, both the TDC and the Pulse Generator must
use exactly the same time base (not shown on the drawings).

Digital architecture brings several advantages compared to analog predecessors: Timestamps generated by the TDC can be also passed to the host system,
and the Pulse Generators can be programmed with arbitrary pulse start times instead of @math{t_{TRIG} + T_{DLY}}. Therefore, @i{FmcDelay} can be used simultaneously as 
a TDC, pulse generator or a pulse delay.

@c ##########################################################################
@node Driver Features
@chapter Driver Features

This driver is based on ZIO and @i{spec-sw}.  It supports initial
setup of the board, setting and reading time, run-time continuous
calibration, input timestamping and output pulse generation.  It
supports user-defined offsets, so our users can tell the driver
about channel-specific delays (for example, to account for wiring) and
ignore the issue in application code.

For each feature offered the driver (and documentation) tries to offer
the following items; sometimes however one of them is missing for a specific
driver functionality, if considered unneeded.

@itemize @bullet
@item A description of how the features works at low level;

@item A low-level user-space program to test the actual mechanism;

@item A C-language API to access the feature with data structures;

@item An example program based on that API.
@end itemize

Additionally, the @code{NewLogger} directory includes the
(uncommented, undocumented) program that has been used (at least for a
while) in the Gran Sasso labs to log neutrino catches.

This package is currently available from
@code{git://gnudd.com/fine-delay.git}, as well as
@code{git://gitorious.org/fine-delay/fine-delay.git}.
Snapshots are released on the ``Files''
and ``Documents'' tabs of the @code{ohwr} project for the related
hardware and gateware.

@c ##########################################################################
@node Installation
@chapter Installation

This driver depends on two other drivers, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the carrier
card.

@menu
* Gateware Dependencies::       
* Gateware Installation::       
* Software Dependencies::       
* Software Installation::       
* Module Parameters::           
@end menu

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This driver has been developed from the FPGA binary included in the
package as @code{binaries/spec_top.bin}, which is White-Rabbit-enabled.
You should use it with @code{binaries/wrc.bin}.

@c This can also be downloaded
@c from the @i{Files} tab of the hardware project:
@c @code{http://www.ohwr.org/projects/fmc-delay-1ns-8cha/files} (direct
@c link:
@c @code{http://www.ohwr.org/attachments/download/1179/spec_top.bin}.

If the gateware is updated, I'll take care to always include in this
package the exact binary the software is developed and verified
against, until the @i{spec-sw} package will offer a hash-based approach
and this package will use it.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{spec-sw}.  To summarize, you'll
need to place the @code{.bin} file, properly renamed, in
@i{/lib/firmware/fmc}.

If you have several @i{fine-delay} cards in the same host, you can
install several copies of the binary, renamed to match the bus and
slot number of the various SPEC cards, or you can use the default
filename if there are no other SPEC cards (i.e. no cards hosting
something else than the @i{fine-delay} module).

If you use the White-Rabbit version of the firmware, you also need
the @code{wrc.bin} file, renamed as @i{spec-sw} looks for it.
In my system, where the @i{fine-delay} card is at bus 2 slot 0, I use
the following two files in @i{/lib/firmware/fmc}:

@smallexample
   -rw------- 1 root   root    58628 May  4 21:15 spec-B0002-cpu.bin
   -rw------- 1 root   root  1485788 May  4 21:14 spec-B0002.bin
@end smallexample

Also, please note that you must pass the parameter @code{lm32=0xc0000}
to the @i{spec.ko} module, because the default address (0x80000) is not
appropriate to the gateware of this device.

@b{Note:} if you are running a slightly earlier version of
@i{spec-sw}, the files for the firmware loaded in @i{spec-sw}
live in @code{/lib/firmware} instead of @code{/lib/firmware/fmc/}.

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The kernel versions I used during development are 2.6.32 and 2.6.24 (in
its @i{preempt-rt} incantation), because these are the ones
where installed boards have been running.

The driver, then is based on the ZIO framework, available from
@code{ohwr.org}. The version being used during development is a development
version, back-ported to Linux-2.6.32 and 2.6.24.
Similarly, this is a sub-module for the SPEC board, and thus relies
on code from the @i{spec-sw} package, again from @code{ohwr.org}.

@c ==========================================================================
@node Software Installation
@section Software Installation

First of all, please note that you need to define the following
environment variables to be able to compile this driver. All of
them are assumed to be already set when running the commands shown.

@table @code
@item LINUX

	The top-level directory of the Linux kernel you are compiling
        against. This document assumes it is already set.

@item ZIO

	The top-level directory of the ZIO repository checkout.

@item SPEC_SW

	The top-level directory of the @i{spec-sw} repository checkout.

@end table

To install ZIO you should download it and install the tag or branch called
@value{tagname}, which has been back-ported to work on Linux-2.6.24 and
Linux-2.6.21.

The commands here are reported without prompt for easy cut-and-paste.

@example
   test -d zio/.git || git clone git://ohwr.org/misc/zio.git
   cd zio
   export ZIO=$(/bin/pwd)
   git checkout -b fine-delay fine-delay-sw-v1.1
   make
   sudo make modules_install
@end example

The procedure for @i{spec-sw} is similar, and again the branch
is called ``@value{tagname}'':

@example
   test -d spec-sw/.git || \
       git clone git://ohwr.org/fmc-projects/spec/spec-sw.git
   cd spec-sw
   export SPEC_SW=$(/bin/pwd)
   git checkout -b fine-delay fine-delay-sw-v1.1
   cd kernel
   make
   sudo make modules_install
@end example

At this point all the software modules are ready to be loaded.
Actually, the right set will be auto-loaded when you @i{modprobe} for
@code{spec-fine-delay} if you installed everything.

@b{Note:} When loading @code{spec.ko}
you @b{must} pass the argument @code{lm32=0xc000}.
The script used by Tomasz is available as
@code{tools/load.sh} for your reference.

This is an example of the kernel messages you'll get back over
a few seconds (initializing the fine-delay card above, takes almost
4 seconds, including the calibration.

@smallexample
   spec_probe (device 0002:0000)
   spec_probe: current 2893 (modprobe)
   spec 0000:02:00.0: PCI INT A -> GSI 18 (level, low) -> IRQ 18
   spec_load_files
   spec 0000:02:00.0: firmware: requesting spec-B0002.bin
   spec_load_fpga: got binary file "spec-B0002.bin", 1485788 (0x16abdc) bytes
   spec 0000:02:00.0: firmware: requesting spec-B0002-cpu.bin
   spec_load_lm32: got program file "spec-B0002-cpu.bin", 59568 (0xe8b0) bytes
   LM32 has been restarted
   spec_load_submodule: load "spec-B0002": 256
   fd_onewire_init: Found DS18xx sensor: 28:85:8c:61:03:00:00:0e
   fd_read_temp: Scratchpad: 12:05:4b:46:7f:ff:0e:10:42
   fd_read_temp: Temperature 0x512 (12 bits: 81.125)
   fd_calibrate_outputs: ch1: 8ns @@846 (f 811, off 35, t 81.12)
   fd_calibrate_outputs: ch2: 8ns @@854 (f 811, off 43, t 81.12)
   fd_calibrate_outputs: ch3: 8ns @@842 (f 811, off 31, t 81.12)
   fd_calibrate_outputs: ch4: 8ns @@846 (f 811, off 35, t 81.12)
   spec_fine_delay: Found i2c device at 0x50
@end smallexample

@c ==========================================================================
@node Module Parameters
@section Module Parameters

The driver accepts a few load-time parameters for configuration. You
can pass them to @i{insmod} directly, or write them in
@code{/etc/modules.conf} or the proper file in @code{/etc/modutils/} .

The following parameters are used:

@table @code

@item regs=

	The @i{regs} parameter defaults to 0x80000 and is the offset of
        fine-delay registers within the PCI memory area.  You shouldn't
        use it unless you are Tomasz Wlostowski or you otherwise
	changed the FPGA design

@item verbose=

	The parameter defaults to 0. If set, it enables more diagnostic
        messages during probe.

@item timer_ms=

	The period of the internal timer. The timer is used to poll
        for input events. We currently have no interrupt support so
        we must poll, but the parameter will remain even when interrupt
        is available, to disable it on request and reuse the current
        polling code. The interval by default is 10ms and currently
        only one timestamp is retrieved at each timer execution.

@item calib_s=

	The period, in seconds, of temperature measurement to re-calibrate
        the output delays. Defaults to 30. If set to zero, the timer is
        not activated.

@end table

@c ##########################################################################
@node Source Code Conventions
@chapter Source Code Conventions

This is a random list of conventions I use in this package

@itemize @bullet

@item All internal symbols in the driver begin with @code{fd_}
(excluding local variables like @i{i} and similar stuff). So you know
if something is local or comes from the kernel.

@item All library functions and public data begin with @code{fdelay_}.

@item The board passed as a library token (@code{struct fdelay_board})
is opaque, so the user doesn't access it.  Internally it is called
@code{userb} because @code{b} is the real one being used. If you need
to access library internals from a user file just define
@code{FDELAY_INTERNAL} before including @code{fdelay-lib.h}.

@item The driver header is called @code{fine-delay.h} while the user one
is @code{fdelay-lib.h}. The latter includes the former, which user
programs should not refer to.  Both are different from the original
implementation (@code{fdelay_lib.h}) to avoid trying to compile older
code with new headers.

@item The @i{tools} directory includes standalone tools that access ZIO
directly. Their name begins with @code{fd-raw-} (but there is a
non-fine-delay tool to generate pulses on the parallel port, which has
a different name pattern).

@item The @i{lib} directory includes example programs for the library.
Unfortunately sources of programs and library files both begin with
@code{fdelay-} -- this is an overlook of mine but I won't fix it.

@end itemize

@c ##########################################################################
@node Using the Driver Directly
@chapter Using the Driver Directly

The driver is designed as a ZIO driver that offers 1 input channel and
4 output channels. Since each output channel is independent (they do
not output at the same time) the device is modeled as 5 separate
@i{csets}.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation (ZIO is an @code{ohwr.org}
project).

@menu
* The device::                  
* Device Attributes::           
* The Input cset::              
* The Output cset::             
@end menu

@c ==========================================================================
@node The device
@section The device

The overall device includes a few device attributes and a few attributes
specific to the csets (some attributes for input and some attributes for
output).
The attributes allow to read and write the internal timing of the
card, as well as other internal parameters, documented below. Since ZIO
has no support for @i{ioctl}, all the attributes appear in @i{sysfs}.
For multi-valued attributes (like a time tag, which is more than 32
bits) the order of reading and writing is mandated by the driver
(e.g.: writing the seconds field of a time must be last, as it is the
action that fires hardware access for all current values).

The device appears in @i{/dev} as a set of char devices:

@smallexample
   spusa# ls -l /dev/zio/*
   crw------- 1 root root 249,   0 Apr 26 00:26 /dev/zio/fd-0200-0-0-ctrl
   crw------- 1 root root 249,   1 Apr 26 00:26 /dev/zio/fd-0200-0-0-data
   crw------- 1 root root 249,  32 Apr 26 00:26 /dev/zio/fd-0200-1-0-ctrl
   crw------- 1 root root 249,  33 Apr 26 00:26 /dev/zio/fd-0200-1-0-data
   crw------- 1 root root 249,  64 Apr 26 00:26 /dev/zio/fd-0200-2-0-ctrl
   crw------- 1 root root 249,  65 Apr 26 00:26 /dev/zio/fd-0200-2-0-data
   crw------- 1 root root 249,  96 Apr 26 00:26 /dev/zio/fd-0200-3-0-ctrl
   crw------- 1 root root 249,  97 Apr 26 00:26 /dev/zio/fd-0200-3-0-data
   crw------- 1 root root 249, 128 Apr 26 00:26 /dev/zio/fd-0200-4-0-ctrl
   crw------- 1 root root 249, 129 Apr 26 00:26 /dev/zio/fd-0200-4-0-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one,
without a @code{zio} subdirectory).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.

In this drivers, @i{cset} 0 is for the input signal, and @i{csets} 1..4 are
for the output channels.

If more than one board is probed for, you'll have two or more similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0200} that follows the device name @code{zio-fd} in the
stanza above. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 2.

For remotely-controlled devices (e.g. Etherbone) the problem will need
to be solved differently.

Device (and channel) attributes can be accessed in the proper @i{sysfs}
directory. For a card in slot 0 of bus 2 (like shown above), the
directory is @i{/sys/bus/zio/devices/fd-0200}:

@smallexample
   spusa# ls -Ff /sys/bus/zio/devices/fd-0200/
   ./      enable           utc-l        subsystem  fd-ch1/
   ../     resolution-bits  coarse       power/     fd-ch2/
   uevent  version          command      driver     fd-ch3/
   name    utc-h            temperature  fd-input/  fd-ch4/
@end smallexample

@c ==========================================================================
@node Device Attributes
@section Device Attributes

Device-wide attributes are the three time tags (@i{utc-h}, @i{utc-l},
@i{coarse}), a read-only @i{version}, a read-only @i{temperature} 
and a write-only @i{command}.
To read device time you
should read @i{utc-h} first.  Reading @u{utc-h} will atomically read
all values from the card and store them in the software driver: when
reading @i{utc-l} and @i{coarse} you'll get such cached values.

Example:
@smallexample
   spusa# cd /sys/bus/zio/devices/fd-0200/
   spusa# cat coarse coarse utc-h coarse
   75136756
   75136756
   0
   47088910
@end smallexample

To set the time, you can write the three values leaving @i{utc-h}
last: writing @i{utc-h} atomically programs the hardware:

@smallexample
   spusa# echo 10000 > coarse; echo 10000 > utc-l; echo 0 > utc-h
   spusa# cat utc-h utc-l
   0
   10003
@end smallexample

The temperature value is scaled by four bits, so you need divide it by
16 to obtain the value in degrees. In this example:

@smallexample
   spusa# cat temperature
   1129
@end smallexample

Temperature is 70.5625 degrees.

If you write 0 to @i{command}, board time will be
synchronized to the current Linux clock within one microsecond
(reading Linux time and writing to the @i{fine-delay} registers is
done with interrupts disabled, so the actual synchronization precision
depends on the speed of your CPU and PCI bus):

@smallexample
   spusa# cat utc-h utc-l; echo 0 > command; cat utc-h utc-l; date +%s
   0
   50005
   0
   1335948116
   1335948116
@end smallexample

However, please note that the times will diverge over time. Also, if
you are using White-Rabbit mode, host time is irrelevant to the board.

I chose to offer a @i{command} channel, which is opaque to the user,
because there are several commands that you may need to send to the
device, and we need to limit the number of attributes. The command numbers
are enumerated in @code{fine-delay.h} and described here below.

@menu
* List of Commands to the Device::  
* Reading Board Time::          
* Writing Board Time::          
@end menu

@c --------------------------------------------------------------------------
@node List of Commands to the Device
@subsection List of Commands to the Device

The following commands are currently supported for the @code{command}
write-only file in @i{sysfs}:

@table @code

@item 0 = FD_CMD_HOST_TIME

	Set board time equal to host time.

@item 1 = FD_CMD_WR_ENABLE

	Enable White-Rabbit mode.

@item 2 = FD_CMD_WR_DISABLE

	Disable White-Rabbit mode.

@item 3 = FD_CMD_WR_QUERY

	Tell the user the status of White-Rabbit mode. This is a hack, as
        the return value is reported using error codes. Success means
        White-Rabbit is synchronized.  @code{ENODEV} means WR mode is inactive,
        @code{EAGAIN} means it is not synchronized yet.
        The error is returned to the @i{write} system call.

@item 4 = FD_CMD_DUMP_MCP

	Force dumping to log messages (using a plain @i{printk} the
        GPIO registers in the MCP23S17 device.

@item 5 = FD_CMD_PURGE_FIFO

	Empty the input fifo and reset the sequence number.

@end table

@c --------------------------------------------------------------------------
@node Reading Board Time
@subsection Reading Board Time

The program @i{fd-raw-gettime}, part of this package, allows reading
the current board time using @i{sysfs} directly:

@smallexample
   spusa# ./tools/fd-raw-gettime ; sleep 1; ./tools/fd-raw-gettime
   3303.076543536
   3304.082016080
@end smallexample

In the example above the time has never been set, so the epoch if FPGA
load time.

@b{Note:} the tool is bugged as of year 2038 because it assumes utc-h is 0.

@c --------------------------------------------------------------------------
@node Writing Board Time
@subsection Writing Board Time

The program @i{fd-raw-settime}, part of this package, allows setting
the current board time using @i{sysfs} directly:

@smallexample
   spusa# ./tools/fd-raw-settime  123; ./tools/fd-raw-gettime
   123.000541696
   spusa# ./tools/fd-raw-settime  123 500000000; ./tools/fd-raw-gettime
   123.500570096
@end smallexample

@b{Note:} the tool is bugged as of year 2038 because it assumes utc-h is 0.

No tool is there to sync the board to Linux time, because writing
0 to the @i{command} attribute is atomic by itself, but there is an
example program using the official API (see @ref{Time Management}).

@c ==========================================================================
@node The Input cset
@section The Input cset

The input cset returns fake data, with timestamp information in the
control block (the meta-information associated to data). This is
suboptimal, but it is a ``good enough'' first implementation until
time permits to refine it.

Currently, no input timestamp is collected until some process calls
the @i{read} function on the control or data char device.

In a perfect world we would have a custom @i{trigger} module that
stuffs the timestamp information directly in the proper place within
the ZIO control block.  This version of the code uses the default ZIO
trigger, which is user-driven.  In other words, data is only requested
to hardware if a user process is actually reading.  This ``software''
trigger sticks a software timestamp in the control block, so the hardware
timestamp must be provided elsewhere.

The hardware timestamp and other information is returned as @i{channel
attributes}, which you can look at using @i{zio-dump} (part of the ZIO
package) or
@i{tools/fd-raw-input} which is part of this package.

@menu
* Input Device Attributes::     
* Reading with zio-dump::       
* Reading with fd-raw-input::   
* Using fd-raw-perf::           
* Configuring the Input Channel::  
* Pulsing from the Parallel Port::  
@end menu

@c --------------------------------------------------------------------------
@node Input Device Attributes
@subsection Input Device Attributes

The attributes are all 32-bit unsigned values, and their meaning
is defined in @i{fine-delay.h} for libraries/applications to use them:

@example
   enum fd_zattr_in_idx {
           FD_ATTR_TDC_UTC_H,
           FD_ATTR_TDC_UTC_L,
           FD_ATTR_TDC_COARSE,
           FD_ATTR_TDC_FRAC,
           FD_ATTR_TDC_SEQ,
           FD_ATTR_TDC_CHAN,
           FD_ATTR_TDC_FLAGS,
           FD_ATTR_TDC_OFFSET,
           FD_ATTR_TDC_USER_OFF,

   }; 
   /* Names have been chosen so that 0 is the default at load time */
   #define FD_TDCF_DISABLE_INPUT	1
   #define FD_TDCF_DISABLE_TSTAMP	2
   #define FD_TDCF_TERM_50		4
@end example

The attributes are also visible in @i{/sys}, in the directory
describing the cset:

@smallexample
   spusa# ls -Ff /sys/bus/zio/devices/fd-0200/fd-input/
   ./      enable           utc-l   chan         power/
   ../     current_trigger  coarse  flags        trigger/
   uevent  current_buffer   frac    offset       chan0/
   name    utc-h            seq     user-offset
@end smallexample

The timestamp-related values in this file reflect the last stamp that
has been enqueued to user space (this may be the next event to be
read by the actual reading process).

The @i{offset} attribute
is the stamping offset, in picoseconds, for the TDC channel.
The @i{user-offset} attribute, which currently defaults to 0, is a
signed value that users can write to represent a number of picoseconds
to be added (or subtracted) to the hardware-reported stamps. This is
used to account for delays induced by cabling (range: -2ms to 2ms).

The @i{flags} attribute can be used to change three configuration
bits, defined by the respective macros. Please note that the default
at module load time is zero: some of the flags bits are inverted
over the hardware counterpart, but the @code{DISABLE} in flag names
is there to avoid potential errors.

@c --------------------------------------------------------------------------
@node Reading with zio-dump
@subsection Reading with zio-dump

This is an example read sequence using @i{zio-dump}: data must be ignored
and only the first few extended attributes are meaningful. This can
be used to see low-level details, but please note
that the programs in @code{tools/} and @code{lib/} in this package are
in general a better choice to timestamp input pulses.

@smallexample
   spusa# zio-dump /dev/zio/fd-0200-0-0-*
   Ctrl: version 0.5, trigger user, dev fd, cset 0, chan 0
   Ctrl: seq 1, n 16, size 4, bits 32, flags 01000001 (little-endian)
   Ctrl: stamp 1335737285.312696982 (0)
   Device attributes:
       [...]
       Extended: 0x0000003f
       0x0 0x30 0x640f20d 0x60a 0x0 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x40 0x454b747 0x1d3 0x1 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x47 0xf04c57 0x772 0x2 0x0 0x0 0x0
@end smallexample

@c --------------------------------------------------------------------------
@node Reading with fd-raw-input
@subsection Reading with fd-raw-input

The @i{tools/fd-raw-input} program, part of this package, is a low-level
program to read input events. It reads
the control devices associated to @i{fine-delay} cards, ignoring the
data devices which are known to not return useful information.
The program can receive
file names on the command line, but reads all fine-delay devices by
default -- it looks for filenames in @i{/dev} using @i{glob} patterns (also
called ``wildcards'').

This is an example run:

@smallexample
   spusa# ./tools/fd-raw-input
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001a 00b9be2b 00000bf2 00000000
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 00e7f5c2 0000097d 00000001
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 02c88901 00000035 00000002
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 03e23c26 000006ce 00000003
@end smallexample

The program offers a ``float'' mode, that reports floating point
time differences between two samples (this doesn't use the @i{frac} delay
value, though, but only the integer second and the coarse 8ns timer).

This is an example while listening to a software-generated 1kHz signal:

@smallexample
   spusa# ./tools/fd-raw-input -f
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.903957552 (delta   0.001007848)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.904971384 (delta   0.001013832)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.905968648 (delta   0.000997264)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.906980376 (delta   0.001011728)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.907997128 (delta   0.001016752)
@end smallexample

The tool reports lost events using the sequence number (attribute number 
4). This is an example using a software-generated burst with a 10us period:

@smallexample
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385815880 (delta   0.000010024)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385825832 (delta   0.000009952)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385835720 (delta   0.000009888)
   /dev/zio/zio-fd-0200-0-0-ctrl: LOST 2770 events
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412775304 (delta   0.026939584)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412784808 (delta   0.000009504)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412794808 (delta   0.000010000)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412804184 (delta   0.000009376)
@end smallexample

The ``pico'' mode of the program (command line argument @code{-p}) is
used to get input time stamps with picosecond precision. In this mode
the program doesn't report the ``second'' part of the stamp. This is
an example run of the program, fed by 1kHz generated from the board
itself:

@smallexample
   spusa.root# ./tools/fd-raw-input -p | head -5
   /dev/zio/zio-fd-0800-0-0-ctrl: 642705121635
   /dev/zio/zio-fd-0800-0-0-ctrl: 643705121647 - delta 001000000012
   /dev/zio/zio-fd-0800-0-0-ctrl: 644705121656 - delta 001000000009
   /dev/zio/zio-fd-0800-0-0-ctrl: 645705121647 - delta 000999999991
   /dev/zio/zio-fd-0800-0-0-ctrl: 646705121664 - delta 001000000017
@end smallexample

If is possible, for diagnostics purposes, to run several modes
at the same time: while @code{-f} and @code{-p} disable raw/hex mode,
the equivalent options @code{-r} and @code{-h} reinstantiate it.
If the input event is reported in more than one format, the filename
is only printed once, and later lines begin with a single blank space
(you may see more blanks because they are part of normal output,
for alignment purposes).

Finally, the program uses two environment variables, if set to any value:
@code{FD_SHOW_TIME} make the tool report the time difference between
sequential reads, which is mainly useful to debug the driver workings;
@code{FD_EXPECTED_RATE} makes the tool report the difference from the
expected data rate, relative to the first sample collected:

@smallexample
   spusa.root# FD_EXPECTED_RATE=1000000000 ./tools/fd-raw-input -p | head -5
   /dev/zio/zio-fd-0800-0-0-ctrl: 139705121668
   /dev/zio/zio-fd-0800-0-0-ctrl: 140705121699 - delta 001000000031 - error  31
   /dev/zio/zio-fd-0800-0-0-ctrl: 141705121661 - delta 000999999962 - error  -7
   /dev/zio/zio-fd-0800-0-0-ctrl: 142705121671 - delta 001000000010 - error   3
   /dev/zio/zio-fd-0800-0-0-ctrl: 143705121689 - delta 001000000018 - error  21
@end smallexample

Please note that the expected rate is a 32-bit integer, so it is limited
to 4ms; moreover it is only used in ``picosecond'' mode.

@c --------------------------------------------------------------------------
@node Using fd-raw-perf
@subsection Using fd-raw-perf

The program @i{tools/fd-raw-perf} gives trivial performance figures for
a train of input pulses. It samples all input events and reports some
statistics when a burst completes (i.e., no pulse is received for at
least 300ms):

@smallexample
   spusa#  ./tools/fd-raw-perf
   59729 pulses (0 lost)
      hw: 1000000000ps (1.000000kHz) -- min 999999926 max 1000000089 delta 163
      sw: 983us (1.017294kHz) -- min 7 max 18992 delta 18985
@end smallexample

The program uses the environment variable @code{PERF_STEP}, if set, to
report information every that many seconds, even if the burst is still
running:

spusa.root# PERF_STEP=5 ./tools/fd-raw-perf
@smallexample
   4999 pulses (0 lost)
      hw: 1000000000ps (1.000000kHz) -- min 999999933 max 1000000067 delta 134
      sw: 1000us (1.000000kHz) -- min 8 max 10001 delta 9993

   4999 pulses (0 lost)
      hw: 1000000000ps (1.000000kHz) -- min 999999926 max 1000000081 delta 155
      sw: 1000us (1.000000kHz) -- min 7 max 18995 delta 18988
@end smallexample

@c --------------------------------------------------------------------------
@node Configuring the Input Channel
@subsection Configuring the Input Channel

There is no support in @i{tools/} to change channel configuration
(but see @ref{Input Configuration} for the official API).
The user is expected to write values in the @i{flags} file directly.
For example, to enable the termination resistors, write 4 to the
@i{flags} file in @i{sysfs}.

@c --------------------------------------------------------------------------
@node Pulsing from the Parallel Port
@subsection Pulsing from the Parallel Port

For my initial tests, some of which are shown above, I generated bursts
of pulses with a software
program (later I used the board itself, for a much better precision).
To do so, I connected a pin of a parallel port plugged on the PCI bus to
the input channel of the @i{fine-delay} card.

The program @i{tools/parport-burst}, part of this package, generates a
burst according to three command line parameters: the I/O port of
the data byte of the parallel port, the repeat count and the duration
of each period. This example makes 1000 pulses of 100 usec each,
using the physical address of my parallel port (if yours is part
of the motherboard, the address is @code{378}):

@example
   ./parport-burst d080 1000 100
@end example

@c ==========================================================================
@node The Output cset
@section The Output cset

The output channels need some configuration to be provided. This
is done using attributes. Attributes can either be written in
@i{sysfs} or can be passed in the control block that accompanies data.

This driver defines the sample size as 4 bytes and the trigger should
be configured for a 1-sample block (the library does it at open
time). We should aim at a zero-size data block, but this would require
a patch to ZIO, and I'd better not change version during development.

The output is configured and activated by writing a control block
with proper attributes set. Then a write to the data channel will
push the block to hardware, for it to be activated.

The driver defines the following attributes:

@example
   /* Output ZIO attributes */
   enum fd_zattr_out_idx {
           FD_ATTR_OUT_MODE = FD_ATTR_DEV__LAST,
           FD_ATTR_OUT_REP,
           /* Start (or delay) is 4 registers */
           FD_ATTR_OUT_START_H,
           FD_ATTR_OUT_START_L,
           FD_ATTR_OUT_START_COARSE,
           FD_ATTR_OUT_START_FINE,
           /* End (start + width) is 4 registers */
           FD_ATTR_OUT_END_H,
           FD_ATTR_OUT_END_L,
           FD_ATTR_OUT_END_COARSE,
           FD_ATTR_OUT_END_FINE,
           /* Delta is 3 registers */
           FD_ATTR_OUT_DELTA_L,
           FD_ATTR_OUT_DELTA_COARSE,
           FD_ATTR_OUT_DELTA_FINE,
           /* The two offsets */
           FD_ATTR_OUT_DELAY_OFF,
           FD_ATTR_OUT_USER_OFF,
           FD_ATTR_OUT__LAST,
   };
   enum fd_output_mode {
           FD_OUT_MODE_DISABLED = 0,
           FD_OUT_MODE_DELAY,
           FD_OUT_MODE_PULSE,
   };
@end example

To disable the output, you must assign 0 to the mode attribute and
other attributes are ignored.  To configure pulse or delay, all
attributes must be set to valid values.

@b{Note:} writing the output configuration (mode, rep, start, end,
delta) to @i{sysfs} is not working with this version of ZIO. And I've
been too lazy to add code to do that.  While recent developments in ZIO
introduced more complete consistency between the various places where
attributes live, with this version you can only write these attributes to
the control block.

The @i{delay-offset} attribute represents an offset that is subtracted
from the user-requested delay (@i{start} fields) when generating output
pulses. It represents internal card delays.  The value can be modified
from @i{sysfs}.

@b{Note:} the @i{delay-offset} is used for delay mode but not
for pulse-generation mode.

The @i{user-offset} attribute, which currently defaults to 0, is a
signed value that users can write to represent a number of picoseconds
to be added (or subtracted) to the every user-command (for both delay
and pulse generation). This is used to account for delays induced by
cabling (range: -2ms to 2ms).  The value can be modified
from @i{sysfs}.

This is the unsorted content of the @i{sysfs} directory for each
of the output csets:

@smallexample
   spusa# ls -fF /sys/bus/zio/devices/zio-fd-0200/fd-ch1
   ./               mode          end-l         user-offset
   ../              rep           end-coarse    power/
   uevent           start-h       end-fine      trigger/
   name             start-l       delta-l       chan0/
   enable           start-coarse  delta-coarse
   current_trigger  start-fine    delta-fine
   current_buffer   end-h         delay-offset
@end smallexample

As said, only @i{delay-offset} and @i{user-offset} are designed to be
read and written by the user. Additionally, @i{mode} can be read to
know whether the channel output or delay event  has triggered.
As of this version, the other attributes are not
readable nor writable in @i{sysfs} --  they are meant to be used
in the control block written to @i{/dev}.

@menu
* Using fd-raw-output::         
@end menu

@c --------------------------------------------------------------------------
@node Using fd-raw-output
@subsection Using fd-raw-output

The simplest way to generate output is using the tools in @code{lib/}.
You are therefore urged to skip this section and read @ref{Output
Configuration} instead.

For the bravest people, the low
level way to generate output is using @i{fd-raw-output}, part
of the @i{tools} directory of this package.  The tool writes a control
block to the ZIO control file, setting the block size to 1 32-bit
sample; it then writes 4 bytes to the data file to force output of the
attributes.

The tool acts on channel 1 (the first) by default, but uses the
environment variable @code{CHAN} if set.  All arguments on the command
line are passed directly in the attributes.  Thus, it is quite a
low-level tool. 

To help the user, any number that begins with @code{+} is added to the
current time (in seconds). It is thus recommended to set the card to follow
system time.

The following example sets card time to 0 and programs 10 pulses at
the beginning of the next second.  The pulses are 8usec long and
repeat after 16usec.  The next example runs 1s of 1kHz square wave.
For readability, numbers are grouped as @i{(mode, delay), (start --
utc-h, utc-l, coarse, frac), (stop -- utc-h, utc-l, coarse, frac),
(delta - utc-l, coarse, frac)}.

@smallexample
   spusa# ./tools/fd-raw-settime 0 0; \
          ./tools/fd-raw-output 2 10   0 1 0 0   0 1 1000 0   0 2000 0

   spusa# ./tools/fd-raw-settime 0 0; \
          ./tools/fd-raw-output 2 500   0 1 0 0   0 1 62500 0   0 125000 0
@end smallexample 

The following example sets board time to host time and programs a single
40us pulse at the beginning of the next second (note use of @code{+})

@smallexample
   spusa# echo 0 > /sys/bus/zio/devices/fd-*/command; \
          ./tools/fd-raw-output 2 0   0 +1 0 0   0 +1 5000 0 
@end smallexample 

The following example programs a pps pulse (1ms long) on channel 1
and a 1MHz square wave on channel 2, assuming board time is already
synchronized with host time:

@smallexample
   spusa# CHAN=1 ./tools/fd-raw-output 2 -1   0 +1 0 0   0 +1 125000 0  1 0 0; \
          CHAN=2 ./tools/fd-raw-output 2 -1   0 +1 0 0   0 +1 64 0   0 125 0
@end smallexample 

@c ##########################################################################
@node Using the Provided API
@chapter Using the Provided API

This chapter describes the higher level interface to the board,
designed for user applications to use.  The code lives in the @i{lib}
subdirectory of this package. The directory uses a plain Makefile (not
a Kbuild one) so it can be copied elsewhere and compiled stand-alone.
Only, it needs a copy of @code{fine-delay.h} (which it currently pulls
from the parent directory) and the ZIO headers, retrieved using the
@code{ZIO} environment variable).

@menu
* Initialization and Cleanup::  
* Time Management::             
* Input Configuration::         
* Reading Input Time-stamps::   
* Output Configuration::        
* White-Rabbit Configuration::  
@end menu

@c ==========================================================================
@node Initialization and Cleanup
@section Initialization and Cleanup

The library offers the following structures and functions:

@table @code

@item struct fdelay_board;

	This is the ``opaque'' token that is being used by library clients.
        If you want to see the internals define @code{FDELAY_INTERNAL}
        and look at @i{fdelay_list.c}.

@item int fdelay_init(void);
@itemx void fdelay_exit(void);

	The former function allocates its internal data and returns
	the number of boards currently found on the system. The latter
        releases any allocated data. If @i{init} fails, it returns -1 with
        a proper @code{errno} value. If no boards are there it returns 0.
        You should not load or unload drivers between @i{init} and @i{exit}.

@item struct fdelay_board *fdelay_open(int index, int dev_id);
@item int fdelay_close(struct fdelay_board *);

	The former function opens a board and returns a token that can
        be used in subsequent calls. The latter function undoes it.
        You can refer to a board either by index or by
        @code{dev_id}. Either argument (but not both) may be -1. If both
        are different from -1 the index and dev_id must match. If a mismatch
        is found, the function return NULL with @code{EINVAL}; if either index or
        @code{dev_id} are not found, the function returns NULL with @code{ENODEV}.

@item struct fdelay_board *fdelay_open_by_lun(int lun);

	The function opens a pointer to a board, similarly to @i{fdelay_open},
        but it uses the Logical Unit Number as argument instead. The LUN
        is used internally be CERN libraries, and the function is needed
        for compatibility with the installed tool-set.  The function uses
        a symbolic link in @i{dev}, created by the local installation procedure.

@end table

The sample program @i{fdelay-list} lists the boards currently on the system,
using @i{fdelay_init}:

@smallexample
   spusa# ./lib/fdelay-list
   ./lib/fdelay-list: found 1 boards
     dev_id 0200, /dev/fd-0200, /sys/bus/zio/devices/fd-0200
@end smallexample

@c ==========================================================================
@node Time Management
@section Time Management

These are the primitives the library offers for time management.

@table @code

@item struct fdelay_time;

	The structure has the same fields as the one in the initial
        user-space library. All but @i{utc} are unsigned 32-bit values
        whereas they were different types in the first library.

@item int fdelay_set_time(struct fdelay_board *b, struct fdelay_time *t);
@itemx int fdelay_get_time(struct fdelay_board *b, struct fdelay_time *t);

	The functions are used to set board time from a user-provided
        time, and to retrieve the current board time to user space.
        The functions return 0 on success. They only use the fields
        @i{utc} and @i{coarse} of @code{struct fdelay_time}.

@item int fdelay_set_host_time(struct fdelay_board *b);

	The function sets board time equal to host time. The precision
        should be in the order of 1 microsecond, but will drift over time.

@end table

The current API clearly lacks a function to report the offset from
board-time and system-time.

The program @i{fdelay-board-time} is a command-line front-end to the library,
to validate the library works as expected:

@smallexample
   spusa# ./lib/fdelay-board-time  25.5; ./lib/fdelay-board-time get
   25.500661824
   spusa# ./lib/fdelay-board-time  get
   34.111048968
   spusa# ./lib/fdelay-board-time  host
   spusa# ./lib/fdelay-board-time  get
   1335974946.493415600
@end smallexample

@c ==========================================================================
@node Input Configuration
@section Input Configuration

To configure the input channel for a board, the library offers the
following function and macros:

@table @code

@item int fdelay_set_config_tdc(struct fdelay_board *b, int flags);
@itemx int fdelay_get_config_tdc(struct fdelay_board *b);

	The function configures a few options in the input channel.
	The @i{flags} argument is a bit-mask of the following three
        values (note that 0 is the default at initialization time).
        The function returns -1 with @code{EINVAL} if the @i{flags}
        argument includes undefined bits.

@item FD_TDCF_DISABLE_INPUT
@itemx FD_TDCF_DISABLE_TSTAMP
@itemx FD_TDCF_TERM_50

	The first bit disables the input channel, the second disables
        acquisition of timestamps, and the last enables the 50-ohm
        termination on the input channel.

@end table

The example program @i{fdelay-term} demonstrates use of the function.
It just enables or disables the 50-ohm resistor.  The effect is
usually verifiable by hooking a scope to the input signal:


@c ==========================================================================
@node Reading Input Time-stamps
@section Reading Input Time-stamps

The library offers the following functions that deal with the input stamps:

@table @code

@item int fdelay_fread(struct fdelay_board *b, struct fdelay_time *t, int n);

	The function behaves like @i{fread}: it tries to read all samples,
        even if it implies sleeping several times.  Use it only if you are
        aware that all the expected pulses will reach you.

@item int fdelay_read(struct fdelay_board *b, struct fdelay_time *t, int n,
		       int flags);

	The function behaves like @i{read}: it will wait at most once
        and return the number of samples that it received.  The @i{flags}
        argument is used to pass 0 or @code{O_NONBLOCK}. If a non-blocking
        read is performed, the function may return -1 with @code{EAGAIN}
        if nothing is pending in the hardware FIFO.
        
@item int fdelay_fileno_tdc(struct fdelay_board *b);

	This returns the file descriptor associated to the TDC device,
        so you can @i{select} or @i{poll} before calling @i{fdelay_read}.
        If access fails (e.g., for permission problems), the functions
        returns -1 with @code{errno} properly set.

@end table

There are two example programs here: one using @i{read} and one using
@i{fread}.

Unfortunately, even if there are samples pending, @i{read}
will only return one of them, because the ZIO device will only see the
next sample slightly after returning the previous one. This is a buffering
problem with our use of ZIO. Here below there were three stamps enqueued,
1ms spaced in time:

@smallexample
   spusa# ./lib/fdelay-read 10
   ./lib/fdelay-read: reading 10 pulses in blocking mode... got 1 of them
   seq   179: time 1447.218417376 + 0ebf
   ./lib/fdelay-read: reading 10 pulses in non-blocking mode... got 1 of them
   seq   180: time 1447.219415872 + 07b5

   spusa# ./lib/fdelay-read 10
   ./lib/fdelay-read: reading 10 pulses in blocking mode... got 1 of them
   seq   181: time 1447.220418000 + 0187
   ./lib/fdelay-read: reading 10 pulses in non-blocking mode... got -1 of them
@end smallexample

This is an example with @i{fread}, where it received two bursts of 5 pulses:
the function didn't return before getting all 10 of them:

@smallexample
   spusa# ./lib/fdelay-fread 10
   ./lib/fdelay-fread: reading 10 pulses using fread... got 10 of them
   seq   182: time 1587.441758984 + 0a4f
   seq   183: time 1587.442757840 + 03b1
   seq   184: time 1587.443757712 + 08f3
   seq   185: time 1587.444757616 + 0a71
   seq   186: time 1587.445757344 + 0480
   seq   187: time 1592.530255160 + 05b7
   seq   188: time 1592.531253896 + 0173
   seq   189: time 1592.532253704 + 0db6
   seq   190: time 1592.533253672 + 0646
   seq   191: time 1592.534253336 + 0752
@end smallexample

There is no example for @i{fdelay_fileno_tdc} using @i{select}.

@c ==========================================================================
@node Output Configuration
@section Output Configuration

The library offers the following functions for output configuration:

@table @code

@item int fdelay_config_pulse(board, channel, pulse_cfg);
@itemx int fdelay_config_pulse_ps(board, channel, pulse_ps_cfg);

	The two functions configure the channel (numbered 0..3)
        for pulse or delay mode. The former function receives
        @code{struct fdelay_pulse} (with split utc/coarse/frac times)
        while the latter receives @code{struct fdelay_pulse_ps}, with
        picosecond-based time values. The functions return 0 on success, -1
        and an error code in @code{errno} in case of failure.

@item int fdelay_has_triggered(struct fdelay_board *b, int channel);

	The function returns 1 of the output channel (numbered 0..3) has
        triggered since the last configuration request, 0 otherwise.

@end table

The configuration functions receive a time configuration. The
starting time is passed as @code{struct fdelay_time}, while the
pulse end and loop period are passed using either the same structure
or a scalar number of picoseconds. These are the relevant structures:

@example
   struct fdelay_time {
           uint64_t utc;
           uint32_t coarse;    uint32_t frac;
           uint32_t seq_id;    uint32_t channel;
   };

   struct fdelay_pulse {
           int mode;           int rep;    /* -1 == infinite */
           struct fdelay_time start, end, loop;
   };

   struct fdelay_pulse_ps {
           int mode;          int rep;
           struct fdelay_time start;
           uint64_t length, period;
   };
@end example

The @code{rep} field represents the repetition count, to output a
train of pulses. The mode field is one of @code{FD_OUT_MODE_DISABLED},
@code{FD_OUT_MODE_DELAY}, @code{FD_OUT_MODE_PULSE}.

The example program to test output generation is called
@code{lib/fdelay-pulse}, and receives several arguments. The
invocation pattern is the following:

@example
   fdelay-pulse [-w] [<dev>] <mode> <ch> <rep> <t1> <t2> <t3>"
@end example

The meaning of the arguments is as follows:

@table @code
@item [-w]

	The switch requests the program to wait for the trigger to
	happen before it returns. If missing, the program returns immediately.

@item [<dev>]

	The optional device number is needed if more than one card is
        plugged in the computer. The form is @code{0200} (bus 02, slot 00).

@item <mode>

	A string: @code{disable}, @code{pulse} or @code{delay}.

@item <ch>

	The channel number: 0 through 3.

@item <rep>

	The repetition count: how many pulses to output: -1 means forever.

@item <t1>
@itemx <t2>
@itemx <t3>

	The three times specifying the pulse burst: @i{t1} is the
        starting time, @i{t2} is the pulse length and @i{t3} is the period
        of the square wave (thus, @i{t1} is absolute and the others are
        relative times.

@end table

The syntax to specify times is of the form @code{second.micro+pico},
where the @i{seconds.micro} part resembles a floating point number and
@i{pico} is scalar. This syntax has been chosen to split the decimal
part in two fields of 6 digits and ease readability. If the
@i{seconds} field begins with @code{+}, the current host utc seconds
are added to the number.

The following example programs a pps pulse (1ms long) on channel 0
and a 1MHz square wave on channel 1, assuming board time is already
synchronized with host time:

@smallexample
   spusa# ./lib/fdelay-pulse  pulse 0 -1  +2.0  0.001    1.0        ;  \
          ./lib/fdelay-pulse  pulse 1 -1  +2.0  0.0+500  0.000001
@end smallexample

This example outputs a train of pulses, 100us long
every 1ms - 10ps:

@smallexample
  ./lib/fdelay-pulse  pulse 0 -1  +2.0  0.0001 0.000999+999990
@end smallexample 

This final example uses delay functionality, requesting 5 pulses on
channel 0, 10ms long with a delay of 100ms from the input pulses
and 100ms period. At the same time channel 1 outputs 6 pulses,
10ms long with a delay of 150ms; period is again 100ms (it's something
pretty clear to looks at on the scope).

@smallexample
  ./lib/fdelay-pulse delay 0 5   0.10 0.01 0.1; \
  ./lib/fdelay-pulse delay 1 6   0.15 0.01 0.1; \
@end smallexample 


@c ==========================================================================
@node White-Rabbit Configuration
@section White-Rabbit Configuration

The following functions are offered:

@table @code

@item int fdelay_wr_mode(struct fdelay_board *b, int on);

	The function receives 0 to disable WR mode or non-0 to enable it.
        It is expected to never fail if the driver is loaded.

@item int fdelay_check_wr_mode(struct fdelay_board *b);

	The function returns 0 if the WR slave is synchronized, @code{EAGAIN}
        (an integer) if it is enabled by not yet synchronized and @code{ENODEV}
        if WR-mode is currently disabled.

@end table

@c ##########################################################################
@node Calibration
@chapter Calibration

Calibration data for a fine-delay card is stored in the I2C FMC EEPROM
device. The FMC standard reserves the initial part of the memory for
its own data structures, so our calibration is stored at offset 0x1800
(6kB over a size of 8kB).

Future releases of this driver are expected to use SDB for describe
flash layout, but the offset of 6kB will be retained for compatibility.

The driver automatically loads calibration data from the flash at
initialization time, but only uses it if its has is valid. The
calibration data is in @code{struct fd_calib} and the on-eeprom structure
is @code{fd_calib_on_eeprom}; both are on show in @file{fine-delay.h}.

If the hash of the data structure found on EEPROM is not valid, the
driver will use the compile-time default values.  You can act on
this configuration using a number of module parameters; please note
that changing calibration data is only expected to happen at production
time.

@table @code

@item calibration_check

This integer parameter, if not zero, makes the driver dump the binary
structure of calibration data in a few places during initialization.
It is mainly a debug tool.

@item calibration_default

The user can set this integer parameter to tell the driver to ignore
calibration data found on the EEPROM, thus enacting the compile-time
defaults.

@item calibration_load

This parameter is a string. The name is used to ask the @i{firmware loader}
to retrieve a file from @file{/lib/firmware}.  The driver tries both
the name it receives, and if that fails a name with bus and @i{devfn}
number appended -- so you can reconfigure a card even if more than one
of them is plugged on the same host.  The data, once read, is used only
if the size is correct (0x54 == 84).

@item calibration_save

The integer parameter is used to request saving calibration data to EEPROM,
whatever values are active after the other parameters have been used.
You can thus save the compiled-in default, the content of the firmware
file just loaded, or the value you just read from EEPROM -- not useful,
but not denied either.

@end table

This package offers no tool to generate the binary file (the 84 bytes
of calibration).


@c ##########################################################################
@node Known Bugs and Missing Features
@chapter Known Bugs and Missing Features

This package is still work in progress, and unfortunately the same
applies to the packages it depends on -- ZIO and @i{spec-sw}.

@menu
* Bugs in Related Packages::    
* Bugs in This Package::        
* Wish List::                   
@end menu

@c ==========================================================================
@node Bugs in Related Packages
@section Bugs in Related Packages

The current package set (i.e., @i{zio}, @i{spec-sw} and this one) has
the following known issues exposed by @i{fine-delay}:

@itemize @bullet
@item The auto-loading of @i{spec} submodules is not really working:
the @i{modprobe} command will be stuck sleeping if you try to use it.
Run `@code{insmod spec-fine-delay}'' (or @i{modprobe}) by hand instead.
@i{This will be addressed in an upcoming release of spec-sw}.

@item The @i{user} trigger of ZIO is really user-driven, so the driver
can't push stuff to the buffer until asked to. Also, a related buglet
prevents to return data immediately when asked. This will be fixed,
but it currently results in the @i{read} function only returning one
sample, and an immediately-following non-blocking @i{read} will say
nothing is there, yet.

@end itemize

@c ==========================================================================
@node Bugs in This Package
@section Bugs in This Package

This is the list of known bugs and missing features over what hardware
allows:

@itemize @bullet

@item We should use interrupts. The input is currently performed with
a kernel timer.

@item Calibration information in the EEPROM is not fixed for
endianness, so it only works on hosts of the same endianness as the
one where it has been programmed.

@item We need a module parameter to avoid probing non-fine-delay SPEC
cards. Reading the magic number from an SPEC that is not programmed
(or likely that is programmed with a different gateware) may lock up
the system.  @i{Actually, this is going to be addressed by a new
approach to loading gateware, set forth in the upcoming spec-sw}.

@end itemize

@c ==========================================================================
@node Wish List
@section Wish List

Other less important issues may be dealt with over time, but are not
urgent as I write this:

@itemize 

@item The driver should register its own ZIO trigger, or use the new
attribute for ``greedy-input'' planned in new versions of ZIO
(thank you Federico). Currently there's no buffering and reading is
slower than it could be.

@item Most example programs only use the ``first'' board in the system.

@item Kernel messages are not very consistent: the code uses both
@i{dev_info} and plain @i{kern_info}.

@item There is clear inconsistency between the various uses of bus
and @i{devfn} numbers, in firmware naming and @i{sysfs} naming. The
inconsistency is mainly between this driver and the SPEC driver, but
this one is more correct.

@end itemize


@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@menu
* ZIO Doesn't Compile::         
* make modules_install misbehaves::  
* Wrong FPGA Image::            
* Version Mismatch::            
@end menu

@c ==========================================================================
@node ZIO Doesn't Compile
@section ZIO Doesn't Compile

Compilation of ZIO ma fail with error like:

@smallexample
   zio-ad788x.c:180: error: implicit declaration of function "spi_async_locked"
@end smallexample

This happens because the function wasn't there in your older kernel
version, and your system is configured to enable @code{CONFIG_SPI}.

To fix, please just remove the @i{zio-ad788x} line from
@code{drivers/Makefile}.

@c ==========================================================================
@node make modules_install misbehaves
@section make modules_install misbehaves

The command @i{sudo make modules_install} may place the modules in the wrong
directory or fail with an error like:

@smallexample
   make: *** /lib/modules/2.6.37+/build: No such file or directory.
@end smallexample

This happens when you compiled by setting @code{LINUX=} and your
@i{sudo} is not propagating the environment to its child processes.
In this case, you should run this command instead

@smallexample
   sudo make modules_install  LINUX=$LINUX
@end smallexample

@c ==========================================================================
@node Wrong FPGA Image
@section Wrong FPGA Image


Thanks to Tomasz, the @i{fine-delay} FPGA binary has a magic number at
a magic address, so the driver can detect if the @i{spec} includes no
gateware or a different binary image.

In this case, a message like the following one is reported:

@example
   fd_probe: card at 0002:0000 has wrong gateware
@end example

If this happens, please put the binary image in @i{/lib/firmware}
where the spec driver can find it. In my case the file name is
@code{spec-B0002.bin} (refer to @i{spec-sw} documentation for details.

@c ==========================================================================
@node Version Mismatch
@section Version Mismatch

The @i{fdelay} library may report a version mismatch like this:

@example
   spusa# ./lib/fdelay-board-time  get
   fdelay_init: version mismatch, lib(1) != drv(2)
   ./lib/fdelay-board-time: fdelay_init(): Input/output error
@end example

This reports a difference in the way ZIO attributes are laid out, so user
space may exchange wrong data in the ZIO control block, or may try to
access inexistent files in @i{/sys}. I suggest recompiling both the kernel
driver and user space from a single release of the source package.


@c ##########################################################################
@bye

@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent FPGA
@c  LocalWords:  setchapternewpage finalout gateware ohwr modprobe insmod cset
@c  LocalWords:  smallexample ctrl timestamp fdelay struct spusa gitorious http
@c  LocalWords:  tagname FmcDelay timestamping Timestamps perf picosecond ATTR
@c  LocalWords:  usec EEPROM sudo
