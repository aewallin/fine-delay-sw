\input texinfo    @c -*-texinfo-*-
%
% fine-delay.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month April 2012

@finalout

@titlepage
@title fine-delay
@subtitle @value{update-month}
@subtitle A sub-driver for ``fmc-delay-1ns-4cha'' based on SPEC driver
@author Alessandro Rubini for CERN
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual for the device driver developed for the
``fmc-delay-1ns-4cha'' board developed on @code{ohwr.org}.  Please
note that the ohwr project is misnamed as @code{fmc-delay-1ns-8cha};
thus the web references include this wrong naming and it's not a typo
in the documentation.

@menu
* Driver Features::             
* Installation::                
* Using the Driver Directly::   
* Using the Provided API::      
* Known bugs and missing features::  
* Troubleshooting::             
@end menu

@c ##########################################################################
@node Driver Features
@chapter Driver Features

@c ##########################################################################
@node Installation
@chapter Installation

This driver depends on two other drivers, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the carrier
card.

@menu
* Gateware Dependencies::       
* Gateware Installation::       
* Software Dependencies::       
* Software Installation::       
* Module Parameters::           
@end menu

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This driver has been developed from the FPGA binary included in the
package as @code{binaries/spec_top.bin}.  This can also be downloaded
from the @i{Files} tab of the hardware project:
@code{http://www.ohwr.org/projects/fmc-delay-1ns-8cha/files} (direct
link:
@code{http://www.ohwr.org/attachments/download/1179/spec_top.bin}.

If the gateware is updated, I'll take care to always include in this
package the exact binary the software is developed and verified
against.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{spec-sw}.  To summarize, you'll
need to place the @code{.bin} file, properly renamed, in
@i{/lib/firmware}.

If you have several @i{fine-delay} cards in the same host, you can
install several copies of the binary, renamed to match the bus and
slot number of the various SPEC cards, or you can use the default
filename if there are no other SPEC cards (i.e. cards hosting
something else than the @i{fine-delay} module).

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The kernel I used during development is version 2.6.32, because this
is the one where installed boards are going to run first.  

The driver, then is based on the ZIO framework, available from
@code{ohw.org}. The version being used during development is a development
version, back-ported to Linux-2.6.32.
Similarly, this is a sub-module for the SPEC board, and thus relies
on code from the @i{spec-sw} package, again from @code{ohwr.org}.

@c ==========================================================================
@node Software Installation
@section Software Installation

First of all, please note that you need to define the following
environment variables to be able to compile this driver. All of
them are assumed to be already set when running the commands shown.

@table @code
@item LINUX

	The top-level directory of the Linux kernel you are compiling
        against. This document assumes it is already set.

@item ZIO

	The top-level directory of the ZIO repository checkout.

@item SPEC_SW

	The top-level directory of the @i{spec-sw} repository checkout.

@end table

To install ZIO you should download it and install the branch called
``for-linux-2.6.32'' (this is the only kernel version this
driver has been tested against so far).

The commands here are reported without prompt for easy cut-and-paste,
and the exact version number is used in the checkout command in order
to ensure you are running the same version that has been used during
development.  We plan to place a permanent tag in the ZIO repository
when this driver is completed.

@example
   test -d zio/.git || git clone git://ohwr.org/misc/zio.git
   cd zio
   export ZIO=$(/bin/pwd)
   git checkout zio-beta3-117-g97387e8 || \
       git checkout origin/for-linux-2.6.32
   make
   sudo make modules_install
@end example

@b{Warning:} the commit-ID above is volatile until this driver is
finalized, that's why the command above retrieves the @i{current}
branch @code{for-linux-2.6.32} if the first checkout fails.


The procedure for @i{spec-sw} is similar, but the master branch will
work in this case. Again, the command shows the exact commit
identifier.

@example
   test -d spec-sw/.git || \
       git clone git://ohwr.org/fmc-projects/spec/spec-sw.git
   cd spec-sw
   export SPEC_SW=$(/bin/pwd)
   git checkout 8be5e1b || 
       git checkout origin/for-linux-2.6.32
   cd kernel
   make
   sudo make modules_install
@end example

@b{Warning:} the commit-ID above is volatile until this driver is
finalized, that's why the command above retrieves the @i{current}
branch @code{for-linux-2.6.32} if the first checkout fails.
@c FIXME: the commit identifiers.

Finally, you need to compile and install this driver, using the following
commands, from the @i{master} branch:

@example
   make
   sudo make modules_install
@end example

At this point all the software modules are ready to be loaded.
Actually, the right set will be auto-loaded when you @i{modprobe} for
@code{spec-fine-delay} if you installed everything.

This is an example of the kernel messages you'll get back over
a few seconds (initializing the fine-delay card above, takes almost
4 seconds, including the calibration.

@smallexample
   spec_probe (device 0002:0000)
   spec_probe: current 2893 (modprobe)
   spec 0000:02:00.0: PCI INT A -> GSI 18 (level, low) -> IRQ 18
   spec_load_files
   spec 0000:02:00.0: firmware: requesting spec-B0002.bin
   spec_load_fpga: got binary file "spec-B0002.bin", 1484404 (0x16a674) bytes
   spec 0000:02:00.0: firmware: requesting spec-B0002-cpu.bin
   spec 0000:02:00.0: Can't load program "spec-B0002-cpu.bin" - -2
   spec_load_submodule: load "spec-B0002": 256
   fd_onewire_init: Found DS18xx sensor: 28:13:f2:06:03:00:00:d4
   fd_read_temp: Scratchpad: eb:04:4b:46:7f:ff:05:10:12
   fd_read_temp: Temperature 0x4eb (12 bits: 78.687)
   fd_calibrate_outputs: ch 1: 8ns @ 837 (f 815, offset 22, t 78.81)
   fd_calibrate_outputs: ch 2: 8ns @ 1022 (f 815, offset 207, t 78.81)
   fd_calibrate_outputs: ch 3: 8ns @ 827 (f 815, offset 12, t 78.81)
   fd_calibrate_outputs: ch 4: 8ns @ 837 (f 815, offset 22, t 78.87)
@end smallexample

@c ==========================================================================
@node Module Parameters
@section Module Parameters

The driver accepts a few load-time parameters for configuration. You
can pass them to @i{insmod} directly, or write them in
@code{/etc/modules.conf} or the proper file in @code{/etc/modutils/} .

The following parameters are used:

@table @code

@item regs=

	The @i{regs} parameter defaults to 0x8400 and is the offset of
        fine-delay registers within the PCI memory area.  You shouldn't
        use it unless you are Tomasz Wlostowski or you otherwise
	changed the FPGA design

@item verbose=

	The parameter defaults to 0. If set, it enables more diagnostic
        messages during probe.

@end table

@c ##########################################################################
@node Using the Driver Directly
@chapter Using the Driver Directly

The driver is designed as a ZIO driver that offsers 1 input channel and
4 output channels. Since each output channel is independent (they do
not output at the same time) the device is modeled as 5 separate
@i{csets}.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation (ZIO is an @code{ohwr.org}
project).

@menu
* The input cset::              
* The oputput cset::            
@end menu

@c ==========================================================================
@node The device
@section The device

@b{Note:} This is not documentation at this point in time, it is
just material for some brainstorming: the code is not there yet.

The overall device includes a few device attributes and the csets.
The attributes allow to read and write the internal timing of the
card, as well as other stuff that may be identified later. Since ZIO
has no support for @i{ioctl}, all the attributes appear in @i{sysfs}.
For multi-valued attributes (like a time tag, which is more than 32
bits) the order of reading and writing is mandated by the driver
(e.g.: writing the seconds field of a time must be last, as it is the
action that fires hardware access for all current values).

The device appears in @i{/dev} as a set of char devices:

@smallexample
   spusa.root# ls -l /dev/zio/*
   crw------- 1 root root 249,   0 Apr 26 00:26 /dev/zio/zio-fd-0000-0-0-ctrl
   crw------- 1 root root 249,   1 Apr 26 00:26 /dev/zio/zio-fd-0000-0-0-data
   crw------- 1 root root 249,  32 Apr 26 00:26 /dev/zio/zio-fd-0000-1-0-ctrl
   crw------- 1 root root 249,  33 Apr 26 00:26 /dev/zio/zio-fd-0000-1-0-data
   crw------- 1 root root 249,  64 Apr 26 00:26 /dev/zio/zio-fd-0000-2-0-ctrl
   crw------- 1 root root 249,  65 Apr 26 00:26 /dev/zio/zio-fd-0000-2-0-data
   crw------- 1 root root 249,  96 Apr 26 00:26 /dev/zio/zio-fd-0000-3-0-ctrl
   crw------- 1 root root 249,  97 Apr 26 00:26 /dev/zio/zio-fd-0000-3-0-data
   crw------- 1 root root 249, 128 Apr 26 00:26 /dev/zio/zio-fd-0000-4-0-ctrl
   crw------- 1 root root 249, 129 Apr 26 00:26 /dev/zio/zio-fd-0000-4-0-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.

If more than one board is probed for, you'll have two similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0000} that follows the device name @code{zio-fd}.

Since probing order of the boards is unpredictable, I'll try to
arrange for @i{dev_id} to be the @i{bus-devfn} values for the host
computer.  For remotely-controlled (e.g. Etherbone) devices the
problem will need to be solved differently.

@c ==========================================================================
@node The input cset
@section The input cset

@b{Note:} This is not documentation at this point in time, it is
just material for some brainstorming: the code is not there yet.

The input cset only returns a time stamp, and it has no associated
data. It can be enabled and disabled at will, and in the first
implementation the device is just polled every 10ms. Interrupt
support will be added soon after the thing works.

The timestamp is returned in the 3-field time stamp structure of
ZIO. No data is associated to the control block, since this is a
TDC device. However, it may turn out that the current version of ZIO
doesn't support 0-sized blocks. In that case I'll add a fake input
datum just to make stuff flow until the problem is fixed upstream.

@c ==========================================================================
@node The oputput cset
@section The output cset

@b{Note:} This is not documentation at this point in time, it is
just material for some brainstorming: the code is not there yet.

The output channels need some configuration to be provided. This
is done using attributes. Attributes can either be written in
@i{sysfs} or can be passed in the control block that sides data.

While in theory we may define the channels as zero-data ones (like the
input channel described earlier), this would prevent a shell user to
configure the output: attributes can be set in @i{sysfs} but then to
fire the action you'll need to write a data block.  This would not be
a problem for compiled code, which will just push attributes to the
control device and would be happy with a zero-lenght data area.

The attributes to be defined are the various parameters of the output
channel: whether it is triggered by the input or is outputting pulses
by itself; the delay; the number of pulses, the two periods, and so
on.

@c ##########################################################################
@node Using the Provided API
@chapter Using the Provided API

@b{Note:} This is not documentation at this point in time, it is
just material for some brainstorming.

The public interface offered by the initial library is like this:

@smallexample
   typedef struct fdelay_device { ... } fdelay_device_t;
   typedef struct { ... } fdelay_time_t;

   fdelay_time_t fdelay_from_picos(const uint64_t ps);
   int64_t fdelay_to_picos(const fdelay_time_t t);

   int fdelay_init(fdelay_device_t *dev);
   int fdelay_release(fdelay_device_t *dev);
   int fdelay_read(fdelay_device_t *dev, fdelay_time_t *timestamps, int how_many);
   int fdelay_configure_trigger(fdelay_device_t *dev, int enable, int termination);
   int fdelay_configure_output(fdelay_device_t *dev, int channel, int enable, int64_t delay_ps, int64_t width_ps, int64_t delta_ps, int rep_count);

   int fdelay_configure_sync(fdelay_device_t *dev, int mode);
   int fdelay_update_sync_status(fdelay_device_t *dev);
   int fdelay_set_time(fdelay_device_t *dev, const fdelay_time_t t);
   int fdelay_configure_pulse_gen(fdelay_device_t *dev, int channel, int enable, fdelay_time_t t_start, int64_t width_ps, int64_t delta_ps, int rep_count);
   int fdelay_channel_triggered(fdelay_device_t *dev, int channel);
   int fdelay_get_time(fdelay_device_t *dev, fdelay_time_t *t);
@end smallexample

While it does everything that's needed for testing, I see some
issues with it and would like to offer something different.

This is a list of issues I find and that must be discussed before the
code is finalized with the final public API:

@table @i

@item Multiple boards

	The ``fdelay_init'' just fills a pointer passed by the user,
        which assumes there is one card only. The function should,
        instead, pass a device id to say which one it wants to open.

@item typedef

	I'd better not use typedefs, for the same reason the kernel
        is avoiding them.

@item fdelay_read

	This is perfect in my opinion. It resembles the @i{read}
        system call, and it's great. We must choose what is the
        structure being returned. I'd love it to be a control block
        or a ZIO timestamp structure. To be decided.  But we need a
        function to enable and disable the channel (and disable
        may flush any pending events, with a flag).  Otherwise we'll
        continue to enqueue events even if nobody is willing to
        receive them.

@item configuring output

	Instead of functions with many parameters I'd better pass
        a pointer to a structure. This simplifies code at the various
        levels and also allows a user to have two or more predefined
        configurations and easily activate either with minimal code.
        In practice, those structures may resemble ZIO attributes, to
        minimize data marshalling and un-marshalling.

@item asking for events

	Instead of a boolean ``channel_triggered'' I'd offer a flag
        to the various functions, similar to O_NONBLOCK for files.
        So the read function may return EAGAIN and we save one level
        of calls.

@end table


@c ##########################################################################
@node Known bugs and missing features
@chapter Known bugs and missing features

This package is still work in progress, and unfortunately the same
applies to the packages it depends on.  The current package set has
the following known issues exposed by @i{fine-delay}:

@itemize @bullet
@item The auto-loading of @i{spec} submodules is not really working:
the @i{modprobe} command will be stuck sleeping if you try to use it.
Run `@code{insmod spec-fine-delay}'' (or @i{modprobe} by hand instead.

@end itemize

Not all features are there, and the package currently lacks these features
over what hardware allows:

@itemize @bullet
@item Everything. Let's be honest: the driver does nothing at this point.
The basics are working but the higher level code is still missing.

@item EEPROM support. The driver uses default calibration settings and
no i2c support is there yet.
@end itemize



@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@menu
* Wrong FPGA Image::            
@end menu

@c ==========================================================================
@node Wrong FPGA Image
@section Wrong FPGA Image


Thanks to Tomasz, the @i{fine-delay} FPGA binary has a magic number at
a magic address, so the driver can detect if the @i{spec} includes no
gateware or a different binary image.

In this case, a message like the following one is reported:

@example
   fd_probe: card at 0002:0000 has wrong gateware
@end example

If this happens, please put the binary image in @i{/lib/firmware}
where the spec driver can find it. In my case the file name is
@code{spec-B0002.bin} (refer to @i{spec-sw} documentation for details.


@c ##########################################################################
@bye

@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent FPGA
@c  LocalWords:  setchapternewpage finalout gateware ohwr
