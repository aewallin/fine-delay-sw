\input texinfo    @c -*-texinfo-*-
%
% fine-delay.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month May 2012

@finalout

@titlepage
@title fine-delay
@subtitle @value{update-month}
@subtitle A sub-driver for ``fmc-delay-1ns-4cha'' based on SPEC driver
@author Alessandro Rubini for CERN
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual for the device driver developed for the
``fmc-delay-1ns-4cha'' board developed on @code{ohwr.org}.  Please
note that the ohwr project is misnamed as @code{fmc-delay-1ns-8cha};
thus the web references include this wrong naming and it's not a typo
in the documentation.

@menu
* Driver Features::             
* Installation::                
* Source Code Conventions::     
* Using the Driver Directly::   
* Using the Provided API::      
* Known Bugs and Missing Features::  
* Troubleshooting::             
@end menu

@c ##########################################################################
@node Driver Features
@chapter Driver Features

@c ##########################################################################
@node Installation
@chapter Installation

This driver depends on two other drivers, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the carrier
card.

@menu
* Gateware Dependencies::       
* Gateware Installation::       
* Software Dependencies::       
* Software Installation::       
* Module Parameters::           
@end menu

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This driver has been developed from the FPGA binary included in the
package as @code{binaries/spec_top.bin}.

As an alternative, you can use a fuller White-Rabbit-enabled version,
includes as @code{binaries/spec_top_wr.bin}. In this case please use
@code{binarsies/wrc.bin} as well.

@c This can also be downloaded
@c from the @i{Files} tab of the hardware project:
@c @code{http://www.ohwr.org/projects/fmc-delay-1ns-8cha/files} (direct
@c link:
@c @code{http://www.ohwr.org/attachments/download/1179/spec_top.bin}.

If the gateware is updated, I'll take care to always include in this
package the exact binary the software is developed and verified
against.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{spec-sw}.  To summarize, you'll
need to place the @code{.bin} file, properly renamed, in
@i{/lib/firmware}.

If you have several @i{fine-delay} cards in the same host, you can
install several copies of the binary, renamed to match the bus and
slot number of the various SPEC cards, or you can use the default
filename if there are no other SPEC cards (i.e. no cards hosting
something else than the @i{fine-delay} module).

If you use the White-Rabbit version of the firmware, you also need
the @code{wrc.bin} file, renamed as @i{spec-sw} looks for it.
In my system, where the @i{fine-delay} card is at bus 2 slot 0, I use
the following two files in @i{/lib/firmware}:

@smallexample
   -rw------- 1 root   root    58628 May  4 21:15 spec-B0002-cpu.bin
   -rw------- 1 root   root  1485788 May  4 21:14 spec-B0002.bin
@end smallexample

Also, please note that if you use the White-Rabbit gatware, you must
pass the parameter @code{lm32=0xc0000} to the @i{spec.ko} module.

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The kernel I used during development is version 2.6.32, because this
is the one where installed boards are going to run first.  

The driver, then is based on the ZIO framework, available from
@code{ohw.org}. The version being used during development is a development
version, back-ported to Linux-2.6.32.
Similarly, this is a sub-module for the SPEC board, and thus relies
on code from the @i{spec-sw} package, again from @code{ohwr.org}.

@c ==========================================================================
@node Software Installation
@section Software Installation

First of all, please note that you need to define the following
environment variables to be able to compile this driver. All of
them are assumed to be already set when running the commands shown.

@table @code
@item LINUX

	The top-level directory of the Linux kernel you are compiling
        against. This document assumes it is already set.

@item ZIO

	The top-level directory of the ZIO repository checkout.

@item SPEC_SW

	The top-level directory of the @i{spec-sw} repository checkout.

@end table

To install ZIO you should download it and install the branch called
``for-linux-2.6.32'' (this is the only kernel version this
driver has been tested against so far).

The commands here are reported without prompt for easy cut-and-paste,
and the exact version number is used in the checkout command in order
to ensure you are running the same version that has been used during
development.  We plan to place a permanent tag in the ZIO repository
when this driver is completed.

@example
   test -d zio/.git || git clone git://ohwr.org/misc/zio.git
   cd zio
   export ZIO=$(/bin/pwd)
   git checkout zio-beta3-117-g97387e8 || \
       git checkout origin/for-linux-2.6.32
   make
   sudo make modules_install
@end example

@b{Warning:} the commit-ID above might change in the future,
that's why the command above retrieves the @i{current}
branch @code{for-linux-2.6.32} if the first checkout fails.
I don't plan to change this during May 2012, though.


The procedure for @i{spec-sw} is similar, but the master branch will
work in this case. Again, the command shows the exact commit
identifier.

@example
   test -d spec-sw/.git || \
       git clone git://ohwr.org/fmc-projects/spec/spec-sw.git
   cd spec-sw
   export SPEC_SW=$(/bin/pwd)
   git checkout cd7e94e || 
       git checkout origin/for-linux-2.6.32
   cd kernel
   make
   sudo make modules_install
@end example

@b{Warning:} the commit-ID above might change in the future,
that's why the command above retrieves the @i{current}
branch @code{for-linux-2.6.32} if the first checkout fails.
I don't plan to change this again during May 2012, though -- but it happened
already.
@c FIXME: the commit identifiers.

At this point all the software modules are ready to be loaded.
Actually, the right set will be auto-loaded when you @i{modprobe} for
@code{spec-fine-delay} if you installed everything.

@b{Note:} if you are using the White-Rabbit version of the firmware,
you should pass the argument @code{lm32=0xc000} to the @i{spec.ko}
module.  The script used by Tomasz is available as
@code{tools/load.sh} for your reference.

This is an example of the kernel messages you'll get back over
a few seconds (initializing the fine-delay card above, takes almost
4 seconds, including the calibration.

@smallexample
   spec_probe (device 0002:0000)
   spec_probe: current 2893 (modprobe)
   spec 0000:02:00.0: PCI INT A -> GSI 18 (level, low) -> IRQ 18
   spec_load_files
   spec 0000:02:00.0: firmware: requesting spec-B0002.bin
   spec_load_fpga: got binary file "spec-B0002.bin", 1484404 (0x16a674) bytes
   spec 0000:02:00.0: firmware: requesting spec-B0002-cpu.bin
   spec 0000:02:00.0: Can't load program "spec-B0002-cpu.bin" - -2
   spec_load_submodule: load "spec-B0002": 256
   fd_onewire_init: Found DS18xx sensor: 28:13:f2:06:03:00:00:d4
   fd_read_temp: Scratchpad: eb:04:4b:46:7f:ff:05:10:12
   fd_read_temp: Temperature 0x4eb (12 bits: 78.687)
   fd_calibrate_outputs: ch 1: 8ns @ 837 (f 815, offset 22, t 78.81)
   fd_calibrate_outputs: ch 2: 8ns @ 1022 (f 815, offset 207, t 78.81)
   fd_calibrate_outputs: ch 3: 8ns @ 827 (f 815, offset 12, t 78.81)
   fd_calibrate_outputs: ch 4: 8ns @ 837 (f 815, offset 22, t 78.87)
@end smallexample

@c ==========================================================================
@node Module Parameters
@section Module Parameters

The driver accepts a few load-time parameters for configuration. You
can pass them to @i{insmod} directly, or write them in
@code{/etc/modules.conf} or the proper file in @code{/etc/modutils/} .

The following parameters are used:

@table @code

@item regs=

	The @i{regs} parameter defaults to 0x80000 and is the offset of
        fine-delay registers within the PCI memory area.  You shouldn't
        use it unless you are Tomasz Wlostowski or you otherwise
	changed the FPGA design

@item verbose=

	The parameter defaults to 0. If set, it enables more diagnostic
        messages during probe.

@item timer_ms=

	The period of the internal timer. The timer is used to poll
        for input events. We currently have no interrupt support so
        we must poll, but the parameter will remain even when interrupt
        is available, to disable it on request and reuse the current
        polling code. The interval by default is 10ms and currently
        only one timestamp is retrieved at each timer execution.

@item calib_s=

	The period, in seconds, of temperature measurement to recalibrate
        the output delays. Defaults to 30. If set to zero, the timer is
        not activated.

@end table

@c ##########################################################################
@node Source Code Conventions
@chapter Source Code Conventions

This is a random list of conventions I use in this package

@itemize @bullet

@item All internal symbols in the driver begin with @code{fd_}
(excluding local variables like @i{i} and similar stuff). So you know
if something is local or comes from the kernel.

@item All library functions and public data begin with @code{fdelay_}.

@item The board passed as a library token (@code{struct fdelay_board})
is opaque, so the user doesn't access it.  Internally it is called
@code{userb} because @code{b} is the real one being used. If you need
to access library internals from a user file just define
@code{FDELAY_INTERNAL} before including @code{fdelay-lib.h}.

@item The driver header is called @code{fine-delay.h} while the user one
is @code{fdelay-lib.h}. The latter includes the former, which user
programs should not refer to.  Both are different from the original
implementation (@code{fdelay_lib.h}) to avoid trying to compile older
code with new headers.

@item The @i{tools} directory includes standalone tools that access ZIO
directly. Their name begins with @code{fd-raw-} (but there is a
non-fine-delay tool to generate pulses on the parallel port, which has
a different name pattern).

@item The @i{lib} directory includes example programs for the library.
Unfortunately sources of programs and library files both begin with
@code{fdelay-} -- this is an overlook of mine but I won't fix it.

@end itemize

@c ##########################################################################
@node Using the Driver Directly
@chapter Using the Driver Directly

The driver is designed as a ZIO driver that offers 1 input channel and
4 output channels. Since each output channel is independent (they do
not output at the same time) the device is modeled as 5 separate
@i{csets}.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation (ZIO is an @code{ohwr.org}
project).

@menu
* The device::                  
* Device Attributes::           
* The Input cset::              
* The Output cset::             
@end menu

@c ==========================================================================
@node The device
@section The device

@b{Note:} This is not real documentation at this point in time, it is
more material for some brainstorming: the code is not complete yet.

The overall device includes a few device attributes and the csets.
The attributes allow to read and write the internal timing of the
card, as well as other stuff that may be identified later. Since ZIO
has no support for @i{ioctl}, all the attributes appear in @i{sysfs}.
For multi-valued attributes (like a time tag, which is more than 32
bits) the order of reading and writing is mandated by the driver
(e.g.: writing the seconds field of a time must be last, as it is the
action that fires hardware access for all current values).

The device appears in @i{/dev} as a set of char devices:

@smallexample
   spusa# ls -l /dev/zio/*
   crw------- 1 root root 249,   0 Apr 26 00:26 /dev/zio/zio-fd-0200-0-0-ctrl
   crw------- 1 root root 249,   1 Apr 26 00:26 /dev/zio/zio-fd-0200-0-0-data
   crw------- 1 root root 249,  32 Apr 26 00:26 /dev/zio/zio-fd-0200-1-0-ctrl
   crw------- 1 root root 249,  33 Apr 26 00:26 /dev/zio/zio-fd-0200-1-0-data
   crw------- 1 root root 249,  64 Apr 26 00:26 /dev/zio/zio-fd-0200-2-0-ctrl
   crw------- 1 root root 249,  65 Apr 26 00:26 /dev/zio/zio-fd-0200-2-0-data
   crw------- 1 root root 249,  96 Apr 26 00:26 /dev/zio/zio-fd-0200-3-0-ctrl
   crw------- 1 root root 249,  97 Apr 26 00:26 /dev/zio/zio-fd-0200-3-0-data
   crw------- 1 root root 249, 128 Apr 26 00:26 /dev/zio/zio-fd-0200-4-0-ctrl
   crw------- 1 root root 249, 129 Apr 26 00:26 /dev/zio/zio-fd-0200-4-0-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.
Cset 0 is input, and csets 1..4 are for the output channels.

If more than one board is probed for, you'll have two similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0200} that follows the device name @code{zio-fd} in the
stanza above. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 2.

For remotely-controlled (e.g. Etherbone) devices the problem will need
to be solved differently.

Device (and channel) attributes can be accessed in the proper @i{sysfs}
directory. For a card in slot 0 of bus 2 (like shown above), the
directory is @i{/sys/bus/zio/devices/zio-fd-0200}:

@smallexample
   spusa# ls -Ff /sys/bus/zio/devices/zio-fd-0200/
   ./      enable           utc-l       power/     fd-ch2/
   ../     resolution-bits  coarse      driver     fd-ch3/
   uevent  version          command     fd-input/  fd-ch4/
   name    utc-h            subsystem   fd-ch1/
@end smallexample

@c ==========================================================================
@node Device Attributes
@section Device Attributes

Device-wide attributes are the three time tags (@i{utc-h}, @i{utc-l},
@i{coarse}), a read-only @i{version} and a write-only @i{command}.
To read device time you
should read @i{utc-h} first.  Reading @u{utc-h} will atomically read
all values from the card and store them in the software driver: by
reading @i{utc-l} and @i{coarse} you'll get such cached values.

Example:
@smallexample
   spusa# cd /sys/bus/zio/devices/zio-fd-0200/
   spusa# cat coarse coarse utc-h coarse
   75136756
   75136756
   0
   47088910
@end smallexample

To set the time, you can write the three values leaving @i{utc-h}
last: writing @i{utc-h} atomically programs the hardware:

@smallexample
   spusa# echo 10000 > coarse; echo 10000 > utc-l; echo 0 > utc-h
   spusa# cat utc-h utc-l
   0
   10003
@end smallexample

If you write 0 to @i{command}, board time will be
synchronized to the current Linux clock within one microsecond
(reading Linux time and writing to the @i{fine-delay} registers is
done with interrupts disabled, so the actual synchronization precision
depends on the speed of your CPU and PCI bus):

@smallexample
   spusa# cat utc-h utc-l; echo 0 > command; cat utc-h utc-l; date +%s
   0
   50005
   0
   1335948116
   1335948116
@end smallexample

I chose to offer a @i{command} channel, which is opaque to the user,
because there are several commands that you may need to send to the
device, and we need to limit the number of attributes. The command numbers
are enumerated in @code{fine-delay.h} 

@menu
* List of Commands to the Device::  
* Reading Board Time::          
* Writing Board Time::          
@end menu

@c --------------------------------------------------------------------------
@node List of Commands to the Device
@subsection List of Commands to the Device

The following commands are currently supported for the @code{command}
write-only file in @i{sysfs}:

@table @code

@item 0 = FD_CMD_HOST_TIME

	Set board time equal to host time.

@item 1 = FD_CMD_WR_ENABLE

	Enable White-Rabbit mode.

@item 2 = FD_CMD_WR_DISABLE

	Disable White-Rabbit mode.

@item 3 = FD_CMD_WR_QUERY

	Tell the user the status of White-Rabbit mode. This is a hack, as
        the return value is reported using error codes. Success means
        White-Rabbit is synchronized.  @code{ENODEV} means there is
        WR mode activa, @code{EAGAIN} means it is not synchronized yet.
        The error is returned to the @i{write} system call.

@end table

@c --------------------------------------------------------------------------
@node Reading Board Time
@subsection Reading Board Time

The program @i{fd-raw-gettime}, part of this package, allows reading
the current board time using @i{sysfs} directly:

@smallexample
   spusa# ./fd-raw-gettime ; sleep 1; ./fd-raw-gettime
   3303.076543536
   3304.082016080
@end smallexample

In the example above the time has never been set, so the epoch if FPGA
load time.

@b{Note:} the tool is bugged as of 2038 because it assumes utc-h is 0.

@c --------------------------------------------------------------------------
@node Writing Board Time
@subsection Writing Board Time

The program @i{fd-raw-settime}, part of this package, allows setting
the current board time using @i{sysfs} directly:

@smallexample
   spusa# ./fd-raw-settime  123; ./fd-raw-gettime
   123.000541696
   spusa# ./fd-raw-settime  123 500000000; ./fd-raw-gettime
   123.500570096
@end smallexample

@b{Note:} the tool is bugged as of 2038 because it assumes utc-h is 0.

No tool is there to sync the board to Linux time, because writing
0 to the @i{command} attribute is atomic by itself.

@c ==========================================================================
@node The Input cset
@section The Input cset

The input cset returns fake data, with timestamp information in the
control block (the meta-information associated to data). This is
suboptimal, but it is a ``good enough'' first implementation until
time permits to refine it.

Currently, no input timestamp is returned until some process calls
the @i{read} function on the control or data char device.

In a perfect world we would have a custom @i{trigger} module that
stuffs the timestamp information directly in the proper place.  This
version of the code uses the default ZIO trigger, which is user-driven.
In other words, data is only requested to hardware if a user process
is actually reading.  This ``software'' trigger sticks a software
timestamp in the control block

The hardware timestamp and other information is returned as @i{channel
attributes}, which you can look at using @code{zio-dump} or
@i{tools/fd-raw-input} which is part of this package.

@menu
* Input Device Attributes::     
* Reading with zio-dump::       
* Reading with fd-raw-input::   
* Configuring the Input Channel::  
* Generating Bursts by Software::  
@end menu

@c --------------------------------------------------------------------------
@node Input Device Attributes
@subsection Input Device Attributes

The attributes are all 32-bit unsigned values, and their meaning
is defined in @i{fine-delay.h} for libraries/applications to use them:

@example
   enum fd_zattr_in_idx {
           FD_ATTR_TDC_UTC_H,
           FD_ATTR_TDC_UTC_L,
           FD_ATTR_TDC_COARSE,
           FD_ATTR_TDC_FRAC,
           FD_ATTR_TDC_SEQ,
           FD_ATTR_TDC_CHAN,
           FD_ATTR_TDC_FLAGS,
           FD_ATTR_TDC_OFFSET,
   }; 
   /* Names have been chosen so that 0 is the default at load time */
   #define FD_TDCF_DISABLE_INPUT	1
   #define FD_TDCF_DISABLE_TSTAMP	2
   #define FD_TDCF_TERM_50		4
@end example

The attributes are also visibile in @i{/sys}, in the directory
describing the cset:

@smallexample
   spusa# ls -Ff /sys/bus/zio/devices/zio-fd-0200/fd-input/
   ./      enable           utc-l   chan         power/
   ../     current_trigger  coarse  flags        trigger/
   uevent  current_buffer   frac    offset       chan0/
   name    utc-h            seq     user-offset
@end smallexample

The timestamp-related values in this file reflect the last stamp that
has been enqueued to user space (this may be the next event to be
read by the actual reading process).  The @i{offset} attribute
is the stamping offset, in picoseconds, for the TDC channel.

The @i{user-offset} attribute, which currently defaults to 0, is a
signed value that users can write to represent a number of picoseconds
to be added (or subtracted) to the hardware-reported stamps. This is
used to account for delays induced by cabling (range: -0.2s to 0.2s).

The @i{flags} attribute can be used to change three configuration
bits, defined by the respective macros. Please note that the default
at module load time is zero, so some of the flags bits are inverted
over the hardware counterpart.

@c --------------------------------------------------------------------------
@node Reading with zio-dump
@subsection Reading with zio-dump

This is an example read sequence using @i{zio-dump}. Data must be ignored
and only the first 6 extended attributes are meaningful.

@smallexample
   spusa# zio-dump /dev/zio/zio-fd-0200-0-0-*
   Ctrl: version 0.5, trigger user, dev fd, cset 0, chan 0
   Ctrl: seq 1, n 16, size 4, bits 32, flags 01000001 (little-endian)
   Ctrl: stamp 1335737285.312696982 (0)
   Device attributes:
       [...]
       Extended: 0x0000003f
       0x0 0x30 0x640f20d 0x60a 0x0 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x40 0x454b747 0x1d3 0x1 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x47 0xf04c57 0x772 0x2 0x0 0x0 0x0
@end smallexample

@c --------------------------------------------------------------------------
@node Reading with fd-raw-input
@subsection Reading with fd-raw-input

The @i{tools/fd-raw-input} program, part of this package, only reads
the control devices associated to @i{fine-delay} cards. It can receive
file names on the command line, but if called with no arguments it
will look for filenames in @i{/dev} using @i{glob} patterns (also
called ``wildcards'').

This is an example run:

@smallexample
   spusa# ./fd-raw-input
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001a 00b9be2b 00000bf2 00000000
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 00e7f5c2 0000097d 00000001
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 02c88901 00000035 00000002
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 03e23c26 000006ce 00000003
@end smallexample

The program also has a ``float'' mode, that reports floating point
time differences between two samples (this doesn't use the fine delay,
though, only the integer second and the coarse 8ns timer).

This is an example while listening to a software-generated 1kHz signal:

@smallexample
   spusa# ./fd-raw-input -f
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.903957552 (delta   0.001007848)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.904971384 (delta   0.001013832)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.905968648 (delta   0.000997264)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.906980376 (delta   0.001011728)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.907997128 (delta   0.001016752)
@end smallexample

The tool reports lost events using the sequence number (attribute number 
4). This is an example using a software-generated burst with a 10us period:

@smallexample
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385815880 (delta   0.000010024)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385825832 (delta   0.000009952)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385835720 (delta   0.000009888)
   /dev/zio/zio-fd-0200-0-0-ctrl: LOST 2770 events
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412775304 (delta   0.026939584)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412784808 (delta   0.000009504)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412794808 (delta   0.000010000)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412804184 (delta   0.000009376)
@end smallexample

@c --------------------------------------------------------------------------
@node Configuring the Input Channel
@subsection Configuring the Input Channel

There is no support in @i{tools/} to change channel configuration.
The user is expected to write values in the @i{flags} file directly.
For example, to enable the termination resistors, write 4 to the
@i{flags} file in @i{sysfs}.

@c --------------------------------------------------------------------------
@node Generating Bursts by Software
@subsection Generating Bursts by Software

For my tests, as shown above, I generate bursts of pulses with a program.
To do so, I connect a pin of a parallel port plugged on the PCI bus to
the input channel of the @i{fine-delay} card.

The program @i{tools/parport-burst}, part of this package, generates a
burst according to three command line parameters: the I/O port of
the data byte of the parallel port, the repeat count and the duration
of each period. This example makes 1000 pulses of 100 usec each,
using the physical address of my parallel port (if yours is part
of the motherboard, the address is @code{378}):

@example
   ./parport-burst d080 1000 100
@end example

@c ==========================================================================
@node The Output cset
@section The Output cset

The output channels need some configuration to be provided. This
is done using attributes. Attributes can either be written in
@i{sysfs} or can be passed in the control block that sides data.

This driver defines the sample size as 4 bytes and the trigger should
be configured for a 1-sample block (the library does it at open
time). We should aim at a zero-size data block, but this would require
a patch to ZIO, and I'd better not change version during development.

The output is configured and activated by writing a control block
with proper attributes set. Then a write to the data channel will
push the block to hardware, for it to be activated.

The following attributes are defined:

@example
   /* Output ZIO attributes */
   enum fd_zattr_out_idx {
           FD_ATTR_OUT_MODE = FD_ATTR_DEV__LAST,
           FD_ATTR_OUT_REP,
           /* Start (or delay) is 4 registers */
           FD_ATTR_OUT_START_H,
           FD_ATTR_OUT_START_L,
           FD_ATTR_OUT_START_COARSE,
           FD_ATTR_OUT_START_FINE,
           /* End (start + width) is 4 registers */
           FD_ATTR_OUT_END_H,
           FD_ATTR_OUT_END_L,
           FD_ATTR_OUT_END_COARSE,
           FD_ATTR_OUT_END_FINE,
           /* Delta is 3 registers */
           FD_ATTR_OUT_DELTA_L,
           FD_ATTR_OUT_DELTA_COARSE,
           FD_ATTR_OUT_DELTA_FINE,
           /* The two offsets */
           FD_ATTR_OUT_DELAY_OFF,
           FD_ATTR_OUT_USER_OFF,
           FD_ATTR_OUT__LAST,
   };
   enum fd_output_mode {
           FD_OUT_MODE_DISABLED = 0,
           FD_OUT_MODE_DELAY,
           FD_OUT_MODE_PULSE,
   };
@end example

So, to disable the output, just write 0 to the mode attribute.
To configure pulse or delay all attributes must be written.

@b{Note:} writing the output configuration (mode, rep, start, end,
delta) to @i{sysfs} is not working with this version of ZIO. And I've
been too lazy to add code to do that.  While recent developments
introduced more complete consistency between the various places where
attributes live, with this version you can only write attributes to
the control block.

The @i{delay-offset} attribute represents an offset that is subtracted
from the user-requested delay (@i{start} fields) when generating output
pulses. It represents internal card delays.  The value can be modified
from @i{sysfs}.

@b{Note:} the @i{delay-offset} is not used for pulse-generation mode.

The @i{user-offset} attribute, which currently defaults to 0, is a
signed value that users can write to represent a number of picoseconds
to be added (or subtracted) to the every user-command (for both delay
and pulse generation). This is used to account for delays induced by
cabling (range: -0.2s to 0.2s).  The value can be modified
from @i{sysfs}.

This is the unsorted content of the @i{sysfs} directory for each
of the output csets:

@smallexample
   spusa# COLUMNS=60 ls -fF /sys/bus/zio/devices/zio-fd-0200/fd-ch1
   ./               mode          end-l         user-offset
   ../              rep           end-coarse    power/
   uevent           start-h       end-fine      trigger/
   name             start-l       delta-l       chan0/
   enable           start-coarse  delta-coarse
   current_trigger  start-fine    delta-fine
   current_buffer   end-h         delay-offset
@end smallexample

As said, only @i{delay-offset} and @i{user-offset} are designed to
be written by the user.

@menu
* Using fd-raw-output::         
@end menu

@c --------------------------------------------------------------------------
@node Using fd-raw-output
@subsection Using fd-raw-output

The simplest way to generate output is using @i{fd-raw-output}, part
of the @i{tools} directory of this package.  The tool writes a control
block to the ZIO control file, setting the block size to 1 32-bit
sample; it then writes 4 bytes to the data file to force output of the
attributes.

The tool acts on channel 1 (the first) by default, but uses the
environment variable @code{CHAN} if set.  All arguments on the command
line are passed directly in the attributes.  Thus, it is quite a
low-level tool. 

To help the user, any number that begins with @code{+} is added to the
current time (in seconds). It is thus recommended to set the card to follow
system time.

The following example sets card time to 0 and programs 10 pulses at
the beginning of the next second.  The pulses are 8usec long and
repeat after 16usec.  The next example runs 1s of 1kHz square wave.
For readability, numbers are grouped as @i{(mode, delay), (start --
utc-h, utc-l, coarse, frac), (stop -- utc-h, utc-l, coarse, frac),
(delta - utc-l, coarse, frac)}.

@smallexample
   spusa# ./fd-raw-settime 0 0; \
          ./fd-raw-output 2 10   0 1 0 0   0 1 1000 0   0 2000 0

   spusa# ./fd-raw-settime 0 0; \
          ./fd-raw-output 2 500   0 1 0 0   0 1 62500 0   0 125000 0
@end smallexample 

The following example sets board time to host time and programs a single
40us pulse at the beginning of the next second (note use of @code{+})

@smallexample
   spusa# echo 0 > /sys/bus/zio/devices/zio-fd-*/command; \
          ./fd-raw-output 2 0   0 +1 0 0   0 +1 5000 0 
@end smallexample 

The following example programs a pps pulse (1ms long) on channel 1
and a 1MHz square wave on channel 2, assuming board time is already
synchronized with host time:

@smallexample
   spusa# CHAN=1 ./fd-raw-output 2 -1   0 +1 0 0   0 +1 125000 0  1 0 0; \
          CHAN=2 ./fd-raw-output 2 -1   0 +1 0 0   0 +1 64 0   0 125 0
@end smallexample 

@b{Note:} mode, that should output pulses delayed over the input, is not
currently working.

@c ##########################################################################
@node Using the Provided API
@chapter Using the Provided API

This chapter describes the higher level interface to the board,
designed for user applications to use.  The code lives in the @i{lib}
subdirectory of this package. The directory uses a plain Makefile (not
a Kbuild one) so it can be copied elsewhere and compiled stand-alone.
Only, it needs a copy of @code{fine-delay.h} (which it currently pulls
from the parent directory) and the ZIO headers, retrieved using the
@code{ZIO} environment variable).

@menu
* The Previous API::            
* Initialization and Cleanup::  
* Time Management::             
* Input Configuration::         
* Reading Input Time-stamps::   
* Output Configuration::        
* White-Rabbit Configuration::  
@end menu

@c ==========================================================================
@node The Previous API
@section The Previous API
The public interface offered by the initial library, written by
Tomasz, is as follows. It covers all device features we need to export:

@smallexample
   typedef struct fdelay_device { ... } fdelay_device_t;
   typedef struct { ... } fdelay_time_t;

   fdelay_time_t fdelay_from_picos(const uint64_t ps);
   int64_t fdelay_to_picos(const fdelay_time_t t);

   int fdelay_init(fdelay_device_t *dev);
   int fdelay_release(fdelay_device_t *dev);
   int fdelay_read(fdelay_device_t *dev, fdelay_time_t *timestamps, int how_many);
   int fdelay_configure_trigger(fdelay_device_t *dev, int enable, int termination);
   int fdelay_configure_output(fdelay_device_t *dev, int channel, int enable,
       int64_t delay_ps, int64_t width_ps, int64_t delta_ps, int rep_count);

   int fdelay_configure_sync(fdelay_device_t *dev, int mode);
   int fdelay_update_sync_status(fdelay_device_t *dev);
   int fdelay_set_time(fdelay_device_t *dev, const fdelay_time_t t);
   int fdelay_configure_pulse_gen(fdelay_device_t *dev, int channel, int enable,
       fdelay_time_t t_start, int64_t width_ps, int64_t delta_ps, int rep_count);
   int fdelay_channel_triggered(fdelay_device_t *dev, int channel);
   int fdelay_get_time(fdelay_device_t *dev, fdelay_time_t *t);
@end smallexample

This API doesn't support multiple boards but is still a useful reference
for the feature-set we need.  The next sections describe the new library,
that is part of this package and relies on the kernel driver.

@c ==========================================================================
@node Initialization and Cleanup
@section Initialization and Cleanup

The library offers the following structures and functions:

@table @code

@item struct fdelay_board;

	This is the ``opaque'' token that is being used by library clients.
        If you want to see the internals define @code{FDELAY_INTERNAL}
        and look at @i{fdelay_list.c}.

@item int fdelay_init(void);
@itemx void fdelay_exit(void);

	The former function allocates its internal data and returns
	the number of boards currently found on the system. The latter
        releases any allocated data. If @i{init} fails, it returns -1 with
        a proper @code{errno} value. If no boards are there it returns 0.
        You should not load or unload drivers between @i{init} and @i{exit}.

@item struct fdelay_board *fdelay_open(int index, int dev_id);
@item int fdelay_close(struct fdelay_board *);

	The former function opens a board and returns a token that can
        be used in subsequent calls. The latter function undoes it.
        You can refer to a board either by index or by
        @code{dev_id}. Either argument (but not both) may be -1. If both
        are different from -1 the index and dev_id must match. If a mismatch
        is found, the function return NULL with @code{EINVAL}; if either index or
        @code{dev_id} are not found, the function returns NULL with @code{ENODEV}.

@end table

The sample program @i{fdelay-list} lists the boards currently on the system,
using @i{fdelay_init}:

@smallexample
   spusa# ./fdelay-list
     dev_id 0200, /dev/zio/zio-fd-0200, /sys/bus/zio/devices/zio-fd-0200
@end smallexample

@c ==========================================================================
@node Time Management
@section Time Management

These are the primitives the library offers for time management.

@table @code

@item struct fdelay_time;

	The structure has the same fields as the one in the initial
        user-space library. All but @i{utc} are unsigned 32-bit values
        whereas they were different types in the first library.

@item int fdelay_set_time(struct fdelay_board *b, struct fdelay_time *t);
@itemx int fdelay_get_time(struct fdelay_board *b, struct fdelay_time *t);

	The functions are used to set board time from a user-provided
        time, and to retrieve the current board time to user space.
        The functions return 0 on success. They only use the fields
        @i{utc} and @i{coarse} of @code{struct fdelay_time}.

@item int fdelay_set_host_time(struct fdelay_board *b);

	The function sets board time equal to host time. The precision
        should be in the order of 1 microsecond, but will drift over time.

@end table

The current API clearly lacks a function to report the offset from
board-time and system-time.

The program @i{fdelay-board-time} is a command-line front-end to the library,
to validate the library works as expected:

@smallexample
   spusa# ./fdelay-board-time  25.5; ./fdelay-board-time get
   25.500661824
   spusa# ./fdelay-board-time  get
   34.111048968
   spusa# ./fdelay-board-time  host
   spusa# ./fdelay-board-time  get
   1335974946.493415600
@end smallexample

@c ==========================================================================
@node Input Configuration
@section Input Configuration

To configure the input channel for a board, the library offers the
following function and macros:

@table @code

@item int fdelay_set_config_tdc(struct fdelay_board *b, int flags);
@itemx int fdelay_get_config_tdc(struct fdelay_board *b);

	The function configures a few options in the input channel.
	The @i{flags} argument is a bitmask of the following three
        values (note that 0 is the default at initialization time).
        The function returns -1 with @code{EINVAL} if the @i{flags}
        argument includes undefined bits.

@item FD_TDCF_DISABLE_INPUT
@itemx FD_TDCF_DISABLE_TSTAMP
@itemx FD_TDCF_TERM_50

	The first bit disables the input channel, the second disables
        acquisition of timestamps, and the last enables the 50-ohm
        termination on the input channel.

@end table

The example program @i{fdelay-term} demonstrates use of the function.
It just enables or disables the 50-ohm resistor.  The effect is
usually verifiable by hooking a scope to the input signal:


@c ==========================================================================
@node Reading Input Time-stamps
@section Reading Input Time-stamps

The library offers the following functions deal with the input stamps:

@table @code

@item int fdelay_fread(struct fdelay_board *b, struct fdelay_time *t, int n);

	The function behaves like @i{fread}: it tries to read all samples,
        even if it implies sleeping several times.  Use it only if you are
        aware that all the expected pulses will reach you.

@item int fdelay_read(struct fdelay_board *b, struct fdelay_time *t, int n,
		       int flags);

	The function behaves like @i{read}: it will wait at most once
        and return the number of samples that it received.  The @i{flags}
        argument is used to pass 0 or @code{O_NONBLOCK}. If a non-blocking
        read is performed, the function may return -1 with @code{EAGAIN}
        if nothing is pending in the hardware fifo.
        
@item int fdelay_fileno_tdc(struct fdelay_board *b);

	This returns the file descriptor associated to the TDC device,
        so you can @i{select} or @i{poll} before calling @i{fdelay_read}.

@end table

There are two example programs here: one using @i{read} and one using
@i{fread}.

Unfortunately, even if there are samples pending, @i{read}
will only return one of them, because the ZIO device will only see the
next sample slightly after returning the previous one. This is a buffering
problem with our use of ZIO. Here below there were three stamps enqueued,
1ms spaced in time:

@smallexample
   spusa# ./fdelay-read 10
   ./fdelay-read: reading 10 pulses in blocking mode... got 1 of them
   seq   179: time 1447.218417376 + 0ebf
   ./fdelay-read: reading 10 pulses in non-blocking mode... got 1 of them
   seq   180: time 1447.219415872 + 07b5

   spusa# ./fdelay-read 10
   ./fdelay-read: reading 10 pulses in blocking mode... got 1 of them
   seq   181: time 1447.220418000 + 0187
   ./fdelay-read: reading 10 pulses in non-blocking mode... got -1 of them
@end smallexample

This is an example with @i{fread}, where it received two bursts of 5 pulses:
the function didn't return before getting all 10 of them:

@smallexample
   spusa# ./fdelay-fread 10
   /fdelay-fread 10
   ./fdelay-fread: reading 10 pulses using fread... got 10 of them
   seq   182: time 1587.441758984 + 0a4f
   seq   183: time 1587.442757840 + 03b1
   seq   184: time 1587.443757712 + 08f3
   seq   185: time 1587.444757616 + 0a71
   seq   186: time 1587.445757344 + 0480
   seq   187: time 1592.530255160 + 05b7
   seq   188: time 1592.531253896 + 0173
   seq   189: time 1592.532253704 + 0db6
   seq   190: time 1592.533253672 + 0646
   seq   191: time 1592.534253336 + 0752
@end smallexample

There is no example for @i{fdelay_fileno_tdc} using @i{select}.

@c ==========================================================================
@node Output Configuration
@section Output Configuration

The API is not implemented, nor the example programs. The header,
however, includes a tentative API, based on structures. Please check
the header and @i{lib/fdelay-output.c} until it is ready.

@c ==========================================================================
@node White-Rabbit Configuration
@section White-Rabbit Configuration

@b{Note:} these functions have not been tested yet, although the low-level
command works.

The following functions are offered

@table @code

@item int fdelay_wr_mode(struct fdelay_board *b, int on);

	The function receives 0 to disable WR mode or non-0 to enable it.
        It is expected to never fail if the driver is loaded.

@item int fdelay_check_wr_mode(struct fdelay_board *b);

	The function returns 0 if the WR slave is synchronized, @code{EAGAIN}
        (an integer) if it is enabled by not yet synchronized and @code{ENODEV}
        if WR-mode is currently disabled.

@end table

@c ##########################################################################
@node Known Bugs and Missing Features
@chapter Known Bugs and Missing Features

This package is still work in progress, and unfortunately the same
applies to the packages it depends on.  The current package set (i.e.,
@i{zio}, @i{spec-sw} and this one) has
the following known issues exposed by @i{fine-delay}:

@itemize @bullet
@item The auto-loading of @i{spec} submodules is not really working:
the @i{modprobe} command will be stuck sleeping if you try to use it.
Run `@code{insmod spec-fine-delay}'' (or @i{modprobe} by hand instead.
@end itemize

This is the list of known bugs and missing features over what hardware
allows:

@itemize @bullet

@item Generation of delayed pulses is missing (it is not working)

@item The API for pulse generation is not yet available.

@item We need interrupt support. The input is performed with a kernel timer.

@item There is no EEPROM support. The driver uses default calibration.
settings.

@item We need a module parameter to avoid probing non-fine-delay SPEC
cards. Reading the magic number from an SPEC that is not programmed
(or likely that is programmed with a different gateware) may lock up
the host computer.

@end itemize

Other less important issues may be dealt with over time, but are not
urgent as I write this:

@itemize 

@item The driver should register its own ZIO trigger, or use the new
attribute for ``greedy-input'' offered in new versions of ZIO
(thank you Federico). Currently there's no buffering and reading is
a little slow.

@item We may implement commands to flush the input queue and reset the
input sequence number.

@item Most example programs only use the ``first'' board in the system.

@end itemize



@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@menu
* ZIO Doesn't Compile::         
* make modules_install misbehaves::  
* Wrong FPGA Image::            
* Version Mismatch::            
@end menu

@c ==========================================================================
@node ZIO Doesn't Compile
@section ZIO Doesn't Compile

Compilation of ZIO ma fail with error like:

@smallexample
   zio-ad788x.c:180: error: implicit declaration of function "spi_async_locked"
@end smallexample

This happens because the function wasn't there in your older kernel
version, and your system is configured to enable @code{CONFIG_SPI}.

To fix, please just remove the @i{zio-ad788x} line from
@code{drivers/Makefile}.

@c ==========================================================================
@node make modules_install misbehaves
@section make modules_install misbehaves

The command @i{sudo make modules_install} may place the modules in the wrong
directory or fail with an error like:

@smallexample
   make: *** /lib/modules/2.6.37+/build: No such file or directory.
@end smallexample

This happens when you compiled by setting @code{LINUX=} and your
@i{sudo} is not propagating the environment to its child processes.
In this case, you should run this command instead

@smallexample
   sudo make modules_install  LINUX=$LINUX
@end smallexample

@c ==========================================================================
@node Wrong FPGA Image
@section Wrong FPGA Image


Thanks to Tomasz, the @i{fine-delay} FPGA binary has a magic number at
a magic address, so the driver can detect if the @i{spec} includes no
gateware or a different binary image.

In this case, a message like the following one is reported:

@example
   fd_probe: card at 0002:0000 has wrong gateware
@end example

If this happens, please put the binary image in @i{/lib/firmware}
where the spec driver can find it. In my case the file name is
@code{spec-B0002.bin} (refer to @i{spec-sw} documentation for details.

@c ==========================================================================
@node Version Mismatch
@section Version Mismatch

The @i{fdelay} library may report a version mismatch like this:

@example
   spusa# ./fdelay-board-time  get
   fdelay_init: version mismatch, lib(1) != drv(2)
   ./fdelay-board-time: fdelay_init(): Input/output error
@end example

This reports a difference in the way ZIO attributes are laid out, so user
space may exchange wrong data in the ZIO control block, or may try to
access inexistent files in @i{/sys}. I suggest recompiling both the kernel
driver and user space from a single release of the source package.


@c ##########################################################################
@bye

@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent FPGA
@c  LocalWords:  setchapternewpage finalout gateware ohwr modprobe insmod cset
@c  LocalWords:  smallexample ctrl timestamp fdelay struct spusa
