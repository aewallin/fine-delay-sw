\input texinfo    @c -*-texinfo-*-
%
% fine-delay.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month April 2012

@finalout

@titlepage
@title fine-delay
@subtitle @value{update-month}
@subtitle A sub-driver for ``fmc-delay-1ns-4cha'' based on SPEC driver
@author Alessandro Rubini for CERN
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual for the device driver developed for the
``fmc-delay-1ns-4cha'' board developed on @code{ohwr.org}.  Please
note that the ohwr project is misnamed as @code{fmc-delay-1ns-8cha};
thus the web references include this wrong naming and it's not a typo
in the documentation.

@menu
* Driver Features::             
* Installation::                
* Using the Driver Directly::   
* Using the Provided API::      
* Known bugs and missing features::  
* Troubleshooting::             
@end menu

@c ##########################################################################
@node Driver Features
@chapter Driver Features

@c ##########################################################################
@node Installation
@chapter Installation

This driver depends on two other drivers, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the carrier
card.

@menu
* Gateware Dependencies::       
* Gateware Installation::       
* Software Dependencies::       
* Software Installation::       
* Module Parameters::           
@end menu

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This driver has been developed from the FPGA binary included in the
package as @code{binaries/spec_top.bin}.  This can also be downloaded
from the @i{Files} tab of the hardware project:
@code{http://www.ohwr.org/projects/fmc-delay-1ns-8cha/files} (direct
link:
@code{http://www.ohwr.org/attachments/download/1179/spec_top.bin}.

If the gateware is updated, I'll take care to always include in this
package the exact binary the software is developed and verified
against.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{spec-sw}.  To summarize, you'll
need to place the @code{.bin} file, properly renamed, in
@i{/lib/firmware}.

If you have several @i{fine-delay} cards in the same host, you can
install several copies of the binary, renamed to match the bus and
slot number of the various SPEC cards, or you can use the default
filename if there are no other SPEC cards (i.e. cards hosting
something else than the @i{fine-delay} module).

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The kernel I used during development is version 2.6.32, because this
is the one where installed boards are going to run first.  

The driver, then is based on the ZIO framework, available from
@code{ohw.org}. The version being used during development is a development
version, back-ported to Linux-2.6.32.
Similarly, this is a sub-module for the SPEC board, and thus relies
on code from the @i{spec-sw} package, again from @code{ohwr.org}.

@c ==========================================================================
@node Software Installation
@section Software Installation

First of all, please note that you need to define the following
environment variables to be able to compile this driver. All of
them are assumed to be already set when running the commands shown.

@table @code
@item LINUX

	The top-level directory of the Linux kernel you are compiling
        against. This document assumes it is already set.

@item ZIO

	The top-level directory of the ZIO repository checkout.

@item SPEC_SW

	The top-level directory of the @i{spec-sw} repository checkout.

@end table

To install ZIO you should download it and install the branch called
``for-linux-2.6.32'' (this is the only kernel version this
driver has been tested against so far).

The commands here are reported without prompt for easy cut-and-paste,
and the exact version number is used in the checkout command in order
to ensure you are running the same version that has been used during
development.  We plan to place a permanent tag in the ZIO repository
when this driver is completed.

@example
   test -d zio/.git || git clone git://ohwr.org/misc/zio.git
   cd zio
   export ZIO=$(/bin/pwd)
   git checkout zio-beta3-117-g97387e8 || \
       git checkout origin/for-linux-2.6.32
   make
   sudo make modules_install
@end example

@b{Warning:} the commit-ID above is volatile until this driver is
finalized, that's why the command above retrieves the @i{current}
branch @code{for-linux-2.6.32} if the first checkout fails.


The procedure for @i{spec-sw} is similar, but the master branch will
work in this case. Again, the command shows the exact commit
identifier.

@example
   test -d spec-sw/.git || \
       git clone git://ohwr.org/fmc-projects/spec/spec-sw.git
   cd spec-sw
   export SPEC_SW=$(/bin/pwd)
   git checkout 8be5e1b || 
       git checkout origin/for-linux-2.6.32
   cd kernel
   make
   sudo make modules_install
@end example

@b{Warning:} the commit-ID above is volatile until this driver is
finalized, that's why the command above retrieves the @i{current}
branch @code{for-linux-2.6.32} if the first checkout fails.
@c FIXME: the commit identifiers.

Finally, you need to compile and install this driver, using the following
commands, from the @i{master} branch:

@example
   make
   sudo make modules_install
@end example

At this point all the software modules are ready to be loaded.
Actually, the right set will be auto-loaded when you @i{modprobe} for
@code{spec-fine-delay} if you installed everything.

This is an example of the kernel messages you'll get back over
a few seconds (initializing the fine-delay card above, takes almost
4 seconds, including the calibration.

@smallexample
   spec_probe (device 0002:0000)
   spec_probe: current 2893 (modprobe)
   spec 0000:02:00.0: PCI INT A -> GSI 18 (level, low) -> IRQ 18
   spec_load_files
   spec 0000:02:00.0: firmware: requesting spec-B0002.bin
   spec_load_fpga: got binary file "spec-B0002.bin", 1484404 (0x16a674) bytes
   spec 0000:02:00.0: firmware: requesting spec-B0002-cpu.bin
   spec 0000:02:00.0: Can't load program "spec-B0002-cpu.bin" - -2
   spec_load_submodule: load "spec-B0002": 256
   fd_onewire_init: Found DS18xx sensor: 28:13:f2:06:03:00:00:d4
   fd_read_temp: Scratchpad: eb:04:4b:46:7f:ff:05:10:12
   fd_read_temp: Temperature 0x4eb (12 bits: 78.687)
   fd_calibrate_outputs: ch 1: 8ns @ 837 (f 815, offset 22, t 78.81)
   fd_calibrate_outputs: ch 2: 8ns @ 1022 (f 815, offset 207, t 78.81)
   fd_calibrate_outputs: ch 3: 8ns @ 827 (f 815, offset 12, t 78.81)
   fd_calibrate_outputs: ch 4: 8ns @ 837 (f 815, offset 22, t 78.87)
@end smallexample

@c ==========================================================================
@node Module Parameters
@section Module Parameters

The driver accepts a few load-time parameters for configuration. You
can pass them to @i{insmod} directly, or write them in
@code{/etc/modules.conf} or the proper file in @code{/etc/modutils/} .

The following parameters are used:

@table @code

@item regs=

	The @i{regs} parameter defaults to 0x8400 and is the offset of
        fine-delay registers within the PCI memory area.  You shouldn't
        use it unless you are Tomasz Wlostowski or you otherwise
	changed the FPGA design

@item verbose=

	The parameter defaults to 0. If set, it enables more diagnostic
        messages during probe.

@item timer_ms=

	The period of the internal timer. The timer is used to poll
        for input events. We currently have no interrupt support so
        we must poll, but the parameter will remain even when interrupt
        is available, to disable it on request and reuse the current
        polling code. The interval by default is 10ms and currently
        only one timestamp is retrieved at each timer execution.

@end table

@c ##########################################################################
@node Using the Driver Directly
@chapter Using the Driver Directly

The driver is designed as a ZIO driver that offers 1 input channel and
4 output channels. Since each output channel is independent (they do
not output at the same time) the device is modeled as 5 separate
@i{csets}.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation (ZIO is an @code{ohwr.org}
project).

@menu
* The input cset::              
* The oputput cset::            
@end menu

@c ==========================================================================
@node The device
@section The device

@b{Note:} This is not real documentation at this point in time, it is
more material for some brainstorming: the code is not complete yet.

The overall device includes a few device attributes and the csets.
The attributes allow to read and write the internal timing of the
card, as well as other stuff that may be identified later. Since ZIO
has no support for @i{ioctl}, all the attributes appear in @i{sysfs}.
For multi-valued attributes (like a time tag, which is more than 32
bits) the order of reading and writing is mandated by the driver
(e.g.: writing the seconds field of a time must be last, as it is the
action that fires hardware access for all current values).

The device appears in @i{/dev} as a set of char devices:

@smallexample
   spusa.root# ls -l /dev/zio/*
   crw------- 1 root root 249,   0 Apr 26 00:26 /dev/zio/zio-fd-0200-0-0-ctrl
   crw------- 1 root root 249,   1 Apr 26 00:26 /dev/zio/zio-fd-0200-0-0-data
   crw------- 1 root root 249,  32 Apr 26 00:26 /dev/zio/zio-fd-0200-1-0-ctrl
   crw------- 1 root root 249,  33 Apr 26 00:26 /dev/zio/zio-fd-0200-1-0-data
   crw------- 1 root root 249,  64 Apr 26 00:26 /dev/zio/zio-fd-0200-2-0-ctrl
   crw------- 1 root root 249,  65 Apr 26 00:26 /dev/zio/zio-fd-0200-2-0-data
   crw------- 1 root root 249,  96 Apr 26 00:26 /dev/zio/zio-fd-0200-3-0-ctrl
   crw------- 1 root root 249,  97 Apr 26 00:26 /dev/zio/zio-fd-0200-3-0-data
   crw------- 1 root root 249, 128 Apr 26 00:26 /dev/zio/zio-fd-0200-4-0-ctrl
   crw------- 1 root root 249, 129 Apr 26 00:26 /dev/zio/zio-fd-0200-4-0-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.
Cset 0 is input, and csets 1..4 are for the output channels.

If more than one board is probed for, you'll have two similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0200} that follows the device name @code{zio-fd} in the
stanza above. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 2.

For remotely-controlled (e.g. Etherbone) devices the problem will need
to be solved differently.

@c ==========================================================================
@node The input cset
@section The input cset

@b{Note:} This is not real documentation at this point in time, it is
more material for some brainstorming: the code is not complete yet.

The input cset returns fake data, with timestamp information in the
control block (the meta-information associated to data). This is
suboptimal, but it is a ``good enough'' first implementation until
time permits to refine it.

Currently, no input timestamp is returned until some process calls
the @i{read} function on the control or data char device.

In a perfect world we would have a custom @i{trigger} module that
stuffs the timestamp information directly in the proper place.  This
version of the code uses the default ZIO trigger, which is
transparent to hardware timings, but sticks a software timestamp in
the control block.

The timestamp and other information is returned as @i{channel
attributes}, which you can look at using @code{zio-dump}
until a specific tool is written for this package:

@smallexample
   spusa# zio-dump /dev/zio/zio-fd-0200-0-0-*
   Ctrl: version 0.5, trigger user, dev fd, cset 0, chan 0
   Ctrl: seq 1, n 16, size 4, bits 32, flags 01000001 (little-endian)
   Ctrl: stamp 1335737285.312696982 (0)
   Device attributes:
       [...]
       Extended: 0x0000003f
       0x0 0x30 0x640f20d 0x60a 0x0 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x40 0x454b747 0x1d3 0x1 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x47 0xf04c57 0x772 0x2 0x0 0x0 0x0
@end smallexample

The attributes are all 32-bit unsigned values, and their meaning
is defined in @i{fine-delay.h} for libraries/applications to use them:

@example
   enum fd_zattr_in_idx {
           FD_ATTR_IN_UTC_H = 0,
           FD_ATTR_IN_UTC_L,
           FD_ATTR_IN_COARSE,
           FD_ATTR_IN_FRAC,
           FD_ATTR_IN_SEQ,
           FD_ATTR_IN_CHAN,
   }; 
@end example

The attributes are also visibile in @i{/sys}, in the directory
describing the cset:

@smallexample
spusa# ls -F /sys/bus/zio/devices/zio-fd-0200/fd-input/
chan    coarse          current_trigger  frac  power/  trigger/  utc-h
chan0/  current_buffer  enable           name  seq     uevent    utc-l
@end smallexample

Note, howver, that the values of those files don't change to reflect
the values last retrieved, to avoid wasting CPU power.  If it is
considered useful, copying over the acquired attributes where
@i{sysfs} can read them is pretty trivial.

@c ==========================================================================
@node The oputput cset
@section The output cset

@b{Note:} This is not documentation at this point in time, it is
just material for some brainstorming: the code is not there yet.

The output channels need some configuration to be provided. This
is done using attributes. Attributes can either be written in
@i{sysfs} or can be passed in the control block that sides data.

While in theory we may define the channels as zero-data ones (like the
input channel described earlier), this would prevent a shell user to
configure the output: attributes can be set in @i{sysfs} but then to
fire the action you'll need to write a data block.  This would not be
a problem for compiled code, which will just push attributes to the
control device and would be happy with a zero-lenght data area.

The attributes to be defined are the various parameters of the output
channel: whether it is triggered by the input or is outputting pulses
by itself; the delay; the number of pulses, the two periods, and so
on.

@c ##########################################################################
@node Using the Provided API
@chapter Using the Provided API

@b{Note:} This is not documentation at this point in time, it is
just material for some brainstorming.

The public interface offered by the initial library is like this:

@smallexample
   typedef struct fdelay_device { ... } fdelay_device_t;
   typedef struct { ... } fdelay_time_t;

   fdelay_time_t fdelay_from_picos(const uint64_t ps);
   int64_t fdelay_to_picos(const fdelay_time_t t);

   int fdelay_init(fdelay_device_t *dev);
   int fdelay_release(fdelay_device_t *dev);
   int fdelay_read(fdelay_device_t *dev, fdelay_time_t *timestamps, int how_many);
   int fdelay_configure_trigger(fdelay_device_t *dev, int enable, int termination);
   int fdelay_configure_output(fdelay_device_t *dev, int channel, int enable, int64_t delay_ps, int64_t width_ps, int64_t delta_ps, int rep_count);

   int fdelay_configure_sync(fdelay_device_t *dev, int mode);
   int fdelay_update_sync_status(fdelay_device_t *dev);
   int fdelay_set_time(fdelay_device_t *dev, const fdelay_time_t t);
   int fdelay_configure_pulse_gen(fdelay_device_t *dev, int channel, int enable, fdelay_time_t t_start, int64_t width_ps, int64_t delta_ps, int rep_count);
   int fdelay_channel_triggered(fdelay_device_t *dev, int channel);
   int fdelay_get_time(fdelay_device_t *dev, fdelay_time_t *t);
@end smallexample

While it does everything that's needed for testing, I see some
issues with it and would like to offer something different.

This is a list of issues I find and that must be discussed before the
code is finalized with the final public API:

@table @i

@item Multiple boards

	The ``fdelay_init'' just fills a pointer passed by the user,
        which assumes there is one card only. The function should,
        instead, pass a device id to say which one it wants to open.

@item typedef

	I'd better not use typedefs, for the same reason the kernel
        is avoiding them.

@item fdelay_read

	This is perfect in my opinion. It resembles the @i{read}
        system call, and it's great. We must choose what is the
        structure being returned. I'd love it to be a control block
        or a ZIO timestamp structure. To be decided.  But we need a
        function to enable and disable the channel (and disable
        may flush any pending events, with a flag).  Otherwise we'll
        continue to enqueue events even if nobody is willing to
        receive them.

@item configuring output

	Instead of functions with many parameters I'd better pass
        a pointer to a structure. This simplifies code at the various
        levels and also allows a user to have two or more predefined
        configurations and easily activate either with minimal code.
        In practice, those structures may resemble ZIO attributes, to
        minimize data marshalling and un-marshalling.

@item asking for events

	Instead of a boolean ``channel_triggered'' I'd offer a flag
        to the various functions, similar to O_NONBLOCK for files.
        So the read function may return EAGAIN and we save one level
        of calls.

@end table


@c ##########################################################################
@node Known bugs and missing features
@chapter Known bugs and missing features

This package is still work in progress, and unfortunately the same
applies to the packages it depends on.  The current package set has
the following known issues exposed by @i{fine-delay}:

@itemize @bullet
@item The auto-loading of @i{spec} submodules is not really working:
the @i{modprobe} command will be stuck sleeping if you try to use it.
Run `@code{insmod spec-fine-delay}'' (or @i{modprobe} by hand instead.

@end itemize

Not all features are there, and the package currently lacks these features
over what hardware allows:

@itemize @bullet
@item Everything. Let's be honest: the driver does nothing at this point.
The basics are working but the higher level code is still missing.

@item EEPROM support. The driver uses default calibration settings and
no i2c support is there yet.
@end itemize



@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@menu
* Wrong FPGA Image::            
@end menu

@c ==========================================================================
@node Wrong FPGA Image
@section Wrong FPGA Image


Thanks to Tomasz, the @i{fine-delay} FPGA binary has a magic number at
a magic address, so the driver can detect if the @i{spec} includes no
gateware or a different binary image.

In this case, a message like the following one is reported:

@example
   fd_probe: card at 0002:0000 has wrong gateware
@end example

If this happens, please put the binary image in @i{/lib/firmware}
where the spec driver can find it. In my case the file name is
@code{spec-B0002.bin} (refer to @i{spec-sw} documentation for details.


@c ##########################################################################
@bye

@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent FPGA
@c  LocalWords:  setchapternewpage finalout gateware ohwr
