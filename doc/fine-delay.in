\input texinfo    @c -*-texinfo-*-
%
% fine-delay.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month August 2013
@c @set release 1.1
@set tagname fine-delay-sw-v2.0
@c WARNING: in @example I Can't use @value{tagname}, so please look for this
@c string when updating the document.

@finalout

@titlepage
@title Fine Delay User's Manual
@subtitle @value{update-month}
@subtitle FMC Delay 1ns-4cha hardware and software manual
@author CERN BE-CO-HT / Tomasz Wlostowski, Alessandro Rubini
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@unnumbered Revision history
@multitable  @columnfractions .10 .15 .25 .50
@headitem Revision @tab Date @tab Author @tab Changes
@item 1.0 @tab April 2012 @tab AR, TW @tab Initial version
@item 2.0 @tab August 2013 @tab AR, TW @tab Updated to 2.0 software/gateware release
@end multitable

@c ##########################################################################
@node Top
@top Introduction

This is the user manual for the
``fmc-delay-1ns-4cha'' board developed on @code{ohwr.org}.  Please
note that the ohwr hardware project is misnamed as @code{fmc-delay-1ns-8cha};
even if the board has 4 channels; the references to @code{8ch} below are thus
correct, even if the may seem wrong.

@c ##########################################################################
@node Repositories and Releases
@chapter Repositories and Releases

The code and documentation is distributed in the following places:

@table @code

@item http://www.ohwr.org/projects/fine-delay-sw/documents

	This place hosts the pdf documentation for some official
        release, but we prefer to use the @i{files} tab, below.

@item http://www.ohwr.org/projects/fine-delay-sw/files

	Here we place the @i{.tar.gz} file for every release,
        including the @i{git} tree and compiled documentation (for
        those who lack TeX), as well as manuals.

@item git://ohwr.org/fmc-projects/fmc-delay-1ns-8cha/fine-delay-sw.git
@itemx git://gitorious.org/fine-delay/fine-delay.git

	Read-only repositories for the software and documentation.
        The former is authoritative, the latter is a backup.

@item git@@ohwr.org:fmc-projects/fmc-delay-1ns-8cha/fine-delay-sw.git
@itemx git@@gitorious.org:fine-delay/fine-delay.git

	Read-write repositories, for those authorized. Again, OHWR is
        the authoritative place, but we tend to push to gitorious as
        well.

@end table

@c The official release of this
@c repository has a tag called called
@c @code{@value{tagname}}. The same tag is used in related
@c repositories (@i{zio}, @i{spec-sw} and the hardware repository).
@c Any official hot fixes, if any,  for this
@c release live in the branch called
@c @code{@value{tagname}-fixes}, in each repository.

@b{Note:} If you got this from the repository (as opposed to a named
@i{tar.gz} or @i{pdf} file) it may happen that you are looking at a later commit
than the release this manual claims to document.
It is a fact of life that developers forget
to re-read and fix documentation while updating the code. In that case,
please run ``@code{git describe HEAD}'' to ensure where you are.

@c ##########################################################################
@node Hardware Description
@chapter Hardware Description

The @i{FMC Delay 1ns-4cha} is an FPGA Mezzanine Card (FMC - VITA 57 standard),
whose main purpose is to produce pulses delayed by a user-programmed value with
respect to the input trigger pulse. The card can also work as a Time to Digital converter (TDC)
or as a programmable pulse generator triggering at a given TAI time. 

 For the sake of clarity of this document, the card's 
name will be further abbreviated as @i{FmcDelay}.

@c ==========================================================================
@node Requirements and Supported Platforms
@section Requirements and Supported Platforms

@i{FmcDelay} can work with any VITA 57-compliant FMC carrier, provided that the carrier's FPGA has enough logic resources. The current software/gateware release (2.0), officially supports the following carrier and mezzanine combinations:

@itemize @bullet
@item CERN's SPEC (Simple PCI-Express Carrier) with one @i{FmcDelay} mezzanine.
@item CERN's SVEC (Simple VME64x Carrier) with one or two @i{FmcDelay} mezzanines. 
Note that if only one @i{FmcDelay} is in use, the other slot should be left empty.
@end itemize
 
Aside from the FMC and its carrier, the following hardware/software components 
are required:

@itemize @bullet
@item For the PCI version: a standard PC with at least one free 4x (or wider) PCI-Express slot.
@item For the VME version: a VME64x crate with a MEN A20 CPU (fixme: can the driver work on RIO or something else?).
@item 50-ohm cables with 1-pin LEMO 00 plugs for connecting the I/O signals.
@item Any Linux (kernel 2.6 or 3.0+) distribution. Backports are provided down to kernel @code{2.6.24}.
@end itemize

@c ==========================================================================
@node Modes of Operation
@section Modes of Operation

@i{FmcDelay} can work in one or more of the following modes:
@itemize @bullet
@item @b{Pulse Delay}: produces one or more pulse(s) on selected outputs
a given time after an input trigger pulse (fig. 1a).
@item @b{Pulse Generator}: produces one or more pulse(s) on selected outputs starting at an
absolute time value programmed by the user (fig. 1b). In this mode, time base is usually provided by the White Rabbit network.
@item @b{Time to Digital Converter}: tags all trigger pulses and delivers the timestamps to the user's application.
@end itemize

@float
@image{drawings/func, 12cm,,,pdf}
@caption{Fig. 1. @i{FmcDelay} operating modes.}
@end float


Modes (pulse delay/generator) can be selected independently for each output. For example, one can configure the output 1 to delay trigger pulses
by 1 us, and the output 2 to produce a pulse at the beginning of each second. The TDC mode can be enabled for the input at any time and
does not interfere with the operation of the channels being time tagged.

@c ==========================================================================
@node Mechanical/Environmental
@section Mechanical/Environmental

@float
@center @image{drawings/front_panels, 16cm,,,pdf}
@caption{Fig. 2. @i{FmcDelay} front panel connector layout.}
@end float

@noindent @b{Mechanical and environmental specs:}
@itemize @bullet
@item Format: FMC (VITA 57), with rear zone for conduction cooling.
@item Operating temperature range: 0 - 90 degC.
@item Carrier connection: 160-pin Low Pin Count FMC connector.
@end itemize

@c ==========================================================================
@node Electrical
@section Electrical

@noindent @b{Inputs/Outputs:}
@itemize @bullet
@item 1 trigger input (LEMO 00).
@item 4 pulse outputs (LEMO 00).
@item 2 LEDs (termination status and trigger indicator).
@item Carrier communication via 160-pin Low Pin Count FMC connector.
@end itemize

@noindent @b{Trigger input:}
@itemize
@item TTL/LVTTL levels, DC-coupled. Reception of a trigger pulse is indicated by blinking the "TRIG" LED in the front panel.
@item 2 kOhm or 50 Ohm input impedance (programmable via software). 50 Ohm termination is indicated by the "TERM" LED in the front panel.
@item Power-up input impedance: 2 kOhm.
@item Protected against short circuit, overcurrent (> 200 mA) and overvoltage (up to +28 V).
@item Maximum input pulse edge rise time: 20 ns.
@end itemize

@noindent @b{Outputs:}
@itemize
@item TTL-compatible levels DC-coupled: Voh = 3 V, Vol = 200 mV (50 Ohm load), Voh = 6 V, Vol = 400 mV (high impedance).
@item Output impedance: 50 Ohm (source-terminated).
@item Rise/fall time: 2.5 ns (10%% - 90%%, 50 Ohm load).
@item Power-up state: LOW (2 kOhm pulldown), guaranteed glitch-free.
@item Protected against continuous short circuit, overcurrent and overvoltage (up to +28 V).
@end itemize

@noindent @b{Power supply:}
@itemize
@item Used power supplies: P12V0, P3V3, P3V3_AUX, VADJ (voltage monitor only).
@item Typical current consumption: 200 mA (P12V0) + 1.5 A (P3V3).
@item Power dissipation: 7 W. Forced cooling is required.
@end itemize

@c ==========================================================================
@node Timing
@section Timing

@float
@image{drawings/io_timing, 14cm,,,pdf}
@caption{Fig. 2. @i{FmcDelay} timing parameter definitions.}
@end float

@noindent @b{Time base:}
@itemize @bullet
@item On-board oscillator accuracy: +/- 2.5 ppm (i.e. max. 2.5 ns error for a delay of 1 ms).
@item When using White Rabbit as the timing reference: depending on the characteristics of the grandmaster clock and the carrier used. On SPEC v 4.0 FMC carrier, the accuracy is better than 1 ns.
@end itemize

@noindent @b{Input timing:}
@itemize @bullet
@item Minimum pulse width: @math{t_{IW}} = 50 ns. Pulses below 24 ns are rejected.
@item Minimum gap between the last delayed output pulse and subsequent trigger pulse: @math{T_{LT}} = 50 ns.
@item Input TDC performance: 400 ps pp accuracy, 27 ps resolution, 70 ps trigger-to-trigger rms jitter (measured at 500 kHz pulse rate).
@end itemize

@noindent @b{Output timing:}
@itemize @bullet
@item Resolution: 10 ps.
@item Accuracy (pulse generator mode): 300 ps.
@item Train generation: trains of 1-65536 pulses or continuous square wave up to 10 MHz.
@item Output-to-output jitter (outputs programmed to the same delay): 10 ps rms.
@item Output-to-output jitter (outputs programmed to to different delays, worst case): 30 ps rms.
@item Output pulse spacing (@math{T_{SP}}) : 100 ns - 16 s. Adjustable in 10 ps steps when both @math{T_{PW}}, @math{T_{GAP}} > 200 ns. Outside that range, @math{T_{SP}} resolution is limited to 4 ns.
@item Output pulse start (@math{t_{START}}) resolution: 10 ps for the rising edge of the pulse, 10 ps for subsequent pulses if the condition above is met, otherwise 4 ns.
@end itemize

@noindent @b{Delay mode specific parameters:}
@itemize @bullet
@item Delay accuracy: < 1 ns.
@item Trigger-to-output jitter: 80 ps rms.
@item Trigger-to-output delay: minimum @math{T_{DLY}} = 600 ns, maximum @math{T_{DLY}} = 120 s.
@item Maximum trigger pulse rate: @math{T_{DLY} + N*(T_{SP} + T_{GAP}) +} 100 ns, where N = number of output pulses. 
@item Trigger pulses are ignored until the output with the biggest delay has finished generation of the pulse(s).
@end itemize


@c ==========================================================================
@node Principles of Operation
@section Principles of Operation

@b{Note:} If you are an electronics engineer, you can skip this section, as you will most likely find it rather boring.

@float
@image{drawings/analog_digital_delays, 16cm,,,pdf}
@caption{Fig. 3. Principle of operation of analog and digital delay generators.}
@end float

Contrary to typical analog delay cards, which work by comparing an analog ramp triggered by the input pulse with a voltage proportional to the desired delay, 
@i{FmcDelay} is a digital delay generator, which relies on time tag arithmetic. The principle of operation of both generators is illustrated in figure 3.

When a trigger pulse comes to the input, @i{FmcDelay} first produces its' precise time tag using a Time-to-Digital converter (TDC). Afterwards, the time tag is summed together 
with the delay preset and the result is passed to a digital pulse generator. In its simplest form, it consists of a free running counter and a comparator. When the counter 
reaches the value provided on the input, a pulse is produced on the output. Note that in order for the system to work correctly, both the TDC and the Pulse Generator must
use exactly the same time base (not shown on the drawings).

Digital architecture brings several advantages compared to analog predecessors: Timestamps generated by the TDC can be also passed to the host system,
and the Pulse Generators can be programmed with arbitrary pulse start times instead of @math{t_{TRIG} + T_{DLY}}. Therefore, @i{FmcDelay} can be used simultaneously as 
a TDC, pulse generator or a pulse delay.

@c ##########################################################################
@node Driver Features
@chapter Driver Features

This driver is based on ZIO and @i{fmc-bus}.  It supports initial
setup of the board, setting and reading time, run-time continuous
calibration, input timestamping and output pulse generation.  It
supports user-defined offsets, so our users can tell the driver
about channel-specific delays (for example, to account for wiring) and
ignore the issue in application code.

For each feature offered the driver (and documentation) the driver
tries to offer
the following items; sometimes however one of them is missing for a specific
driver functionality, if we don't consider it important enough.

@itemize @bullet
@item A description of how the features works at low level;

@item A low-level user-space program to test the actual mechanism;

@item A C-language API to access the feature with data structures;

@item An example program based on that API.
@end itemize

@c ##########################################################################
@node Installation
@chapter Installation

This driver depends on four other modules (four @code{ohwr.org}
packages), as well as the Linux kernel.  Also, it
must talk to a specific FPGA binary file running in the device.

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This version of the driver has been developed to run with
the FPGA binaries included in the package as:
@itemize @bullet
@item @code{binaries/svec-fine-delay.bin} for the SVEC (VME64x) carrier,
@item @code{binaries/spec-fine-delay.bin} for the SPEC (PCI-Express) carrier.
@end itemize

@c Earlier versions required to load a @i{wrc} (White Rabbit Core) program
@c that runs in the internal LM32 soft core, but with this version this
@c step is not required (the program is already part of the FPGA binary).
@c However, if you want to replace it, the default name to use
@c is @code{fine-delay-wrc.bin}. @b{Note}: this specific version of
@c the driver does not support loading the LM32 program separately.

@c This can also be downloaded
@c from the @i{Files} tab of the hardware project:
@c @code{http://www.ohwr.org/projects/fmc-delay-1ns-8cha/files} (direct
@c link:
@c @code{http://www.ohwr.org/attachments/download/1179/spec_top.bin}.

If the gateware is updated, I'll take care to always include in this
package the exact binary the software is developed and verified
against.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instructions in the documentation of @i{spec-sw} (the suggested
version to match this packages is @t{v2013-04}) or @i{svec-sw} (fixme: which version?),
or the one for your specific FMC carrier.
To summarize, you'll
need to place the @code{.bin} file, properly renamed, in
@i{/lib/firmware} or a subdirectory thereof.
The default name used by this driver is
@file{fmc/[carrier]-fine-delay.bin}.

If you have several @i{fine-delay} cards in the same host, you can
load different binaries in different cards, using appropriate
module parameters.

@c @code{wrc=1} to force loading the LM32 program (the package is designed
@c for the final ``perfect'' gateware, which won't need an external WRC
@c binary to be loaded.

@c FIXME: wrc loading is not there.

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The kernel versions I am using during development is 3.4.  Everything
used here is known to build with all versions since 2.6.32 and up to 3.8.
A backport to version 2.6.24 is released as a separate @i{git} branch.

The driver, then, is based on the ZIO framework, available from
@code{ohwr.org}.  I'm developing with the @code{v1.0-fixes} branch of
the framework.  Again, this commit of ZIO is known
to work in the kernel range 2.6.32..3.8 and a backport to 2.6.24 is
available.

The FMC mezzanine is supported by means of the @i{fmc-bus}
software project. This @i{fine-delay}
kernel module registers as a @i{driver} for the FMC bus abstraction,
and is verified with version @t{v2013-04} of the FMC package.
The same kernel range applies.

Both packages (ZIO and @i{fmc-bus})
are currently checked out as @i{git submodules}
of this package, and each of them is retrieved at the right version
to be compatible with this driver.  This means you may just
ignore software dependencies and everything should work.

The carrier driver is not strictly related to this package, but
@i{fine-delay} is released against version @t{v2013-04} of
@i{spec-sw} and version @t{fixme} of @i{svec-sw}. 

(fixme) Unfortunately, all the packages are moving fast: we are approaching a stable
and long-lasting status but we are not there yet.  Please stick
to the released versions named in this section, unless you are involved
in development.

@c ==========================================================================
@node Software Installation
@section Software Installation

To install this software package, you need to tell it where your
kernel sources live, so the package can pick the right header files.
You need to set only one environment variable:

@table @code
@item LINUX

	The top-level directory of the Linux kernel you are compiling
        against. If not set, the default may work if you compile in the same
        host where you expect to run the driver.

@end table

Most likely, this is all you need to set. After this, you can
run:

@example
    make
    sudo make install LINUX=$LINUX
@end example

In addition to the normal installation procedure for
@code{fmc-fine-delay.ko} you'll see the following message:

@example
    WARNING: Consider "make prereq_install"
@end example

The @i{prerequisite} packages are @i{zio} and @i{fmc-bus};
unless you already installed your own preferred version, you are
expected to install the version this packages suggests. This step
can be performed by:

@example
    make
    sudo make prereq_install LINUX=$LINUX
@end example

The step is not performed by default to avoid overwriting some
other versions of the drivers. After @code{make prereq_install},
the warning message won't be repeated any more if you change this
driver and @code{make install} again.

After installation, your carrier driver should load automatically
(for example, the PCI bus will load @code{spec.ko}), but @code{
fmc-fine-delay.ko} must be loaded manually, because support for
automatic loading is not yet in place. The suggested command is
one or the other of the following two:

@smallexample
   modprobe fmc-fine-delay [<parameter> ...]         # after make install
   insmod kernel/fmc-fine-delay.ko [<parameter> ...]  # if not installed
@end smallexample

Available module parameters are described in @ref{Module Parameters}.
Unless you customized or want to customize one of the three
related packages, you can skip the rest of this section.


@sp 1

In order to compile @i{fine-delay} against a specific repository of one
of the related packages, ignoring the local @i{submodule}
you can use one or more of the following
environment variables:

@table @code

@item ZIO
@itemx FMC_BUS

	The top-level directory of the repository checkout of each
        package. Most users won't need to set them, as the Makefiles
        point them to the proper place by default.

@end table

If any of the above is set, headers and dependencies for the
respective package are taken from the chosen directory. If you
@code{make prereq_install} with any of these variables set, they are
be used to know where to install from, instead of using local submodules.

@c ==========================================================================
@node Module Parameters
@section Module Parameters

The driver accepts a few load-time parameters for configuration. You
can pass them to @i{insmod} amd @i{modprobe} directly, or write them
in @code{/etc/modules.conf} or the proper file in @code{/etc/modutils/}.

The following parameters are used:

@table @code

@c @item wrc=
@c 
@c         Load the LM32 @i{White Rabbit Core} program. Here you can
@c         pass a file-name different from the default
@c         (@code{fine_delay-wrc.bin}). If you just pass ``@code{1}''
@c         as name, the driver will force loading the default name.
@c         @b{Note:} this is currently not working.
@c FIXME

@item verbose=

	The parameter defaults to 0. If set, it enables more diagnostic
        messages during probe (you may find it is not used, but it is
        left in to be useful during further development, and avoid
        compile-time changes like use of @code{DEBUG}).

@item timer_ms=

	The period of the internal timer, if not zero.
        The timer is used to poll for input events instead of enabling
        the interrupt.  The default interval is 0, which means to
        use interrupt support. You may want to use the timer while
        porting to a different carrier, before sorting out IRQ issues.

@item calib_s=

	The period, in seconds, of temperature measurement to re-calibrate
        the output delays. Defaults to 30. If set to zero, the
        re-calibration timer is not activated.

@end table

The module also uses the two parameters provided by the @i{fmc}
framework:

@table @code

@item busid=

	A list of bus identifiers the driver will accept to driver.
        Other identifiers will lead to a failure in the @i{probe}
        function. The meaning of the identifiers is carrier-specific;
        the SPEC uses the bus number and @i{devfn}, where the latter
        is most likely zero.

@item gateware=

	A list of gateware file names. The names passed are made to
        match the @i{busid} parameters, in the same order. This
        means that you can't make the driver load a different gateware
        file without passing the respective @i{busid}. Actually, to
        change the gateware for all boards, you may just replace
        the file in @file{/lib/firmware}. (Maybe I'll add an
        option to change the name at load time for all boards).
@c FIXME: name for gateware file (the global one)

@end table

For example, this host has two SPEC cards:

@smallexample
   spusa.root# lspci | grep CERN
   02:00.0 Non-VGA unclassified device: CERN/ECP/EDU Device 018d (rev 03)
   04:00.0 Non-VGA unclassified device: CERN/ECP/EDU Device 018d (rev 03)
@end smallexample

One of the cards hosts a @i{fine-delay} mezzanine and the other does
not. FMC identifiers are not yet used by this driver at this point in time.
(They will be there in  the next release: code is there but not finalized).
So, here
you can use @code{busid=} to choose which SPEC must use @i{fine-delay},
leaving the other one alone:

@smallexample
spusa.root# insmod fmc-fine-delay.ko busid=0x0200
[ 4603.994936] spec 0000:02:00.0: Driver has no ID: matches all
[ 4604.000624] spec 0000:02:00.0: reprogramming with fmc/fine-delay.bin
[ 4604.206515] spec 0000:02:00.0: FPGA programming successful
[ 4604.212442] spec 0000:02:00.0: Gateware successfully loaded
[ 4604.218037] spec 0000:02:00.0: fd_regs_base is 80000
[ 4604.223023] spec 0000:02:00.0: fmc_fine_delay: initializing
[ 4604.228624] spec 0000:02:00.0: calibration: version 3, date 20130427
[ 4605.691404] fd_read_temp: Scratchpad: 9f:04:4b:46:7f:ff:01:10:89
[ 4605.697615] fd_read_temp: Temperature 0x49f (12 bits: 73.937)
[ 4606.645545] fd_calibrate_outputs: ch1: 8ns @@859 (f 827, off 32, t 71.00)
[ 4606.815228] fd_calibrate_outputs: ch2: 8ns @@867 (f 827, off 40, t 71.00)
[ 4607.001027] fd_calibrate_outputs: ch3: 8ns @@854 (f 827, off 27, t 71.00)
[ 4607.187007] fd_calibrate_outputs: ch4: 8ns @@859 (f 827, off 32, t 71.00)
[ 4607.356103] fmc_fine_delay: Found i2c device at 0x50
[ 4607.364039] spec 0000:02:00.0: Using interrupts for input
[ 4607.369549] spec 0000:04:00.0: Driver has no ID: matches all
[ 4607.375243] spec 0000:04:00.0: not using "fmc_fine_delay" according to modparam
@end smallexample

If you use @code{show_sdb=1}, you'll get the following dump of the
internal SDB structure to @i{printk}. The @i{Self Describing Bus} data
structure is described in the documentation of the
@i{fpga-config-space} project, under @code{ohwr.org}.

@smallexample
SDB: 00000651:e6a542c9 WB4-Crossbar-GSI
SDB: 0000ce42:f19ede1a Fine-Delay-Core     (00080000-000807ff)
SDB: 00000651:eef0b198 WB4-Bridge-GSI      (bridge: 000c0000)
SDB:    00000651:e6a542c9 WB4-Crossbar-GSI
SDB:    0000ce42:66cfeb52 WB4-BlockRAM        (000c0000-000d5fff)
SDB:    00000651:eef0b198 WB4-Bridge-GSI      (bridge: 000e0000)
SDB:       00000651:e6a542c9 WB4-Crossbar-GSI
SDB:       0000ce42:ab28633a WR-Mini-NIC         (001a0000-001a00ff)
SDB:       0000ce42:650c2d4f WR-Endpoint         (001a0100-001a01ff)
SDB:       0000ce42:65158dc0 WR-Soft-PLL         (001a0200-001a02ff)
SDB:       0000ce42:de0d8ced WR-PPS-Generator    (001a0300-001a03ff)
SDB:       0000ce42:ff07fc47 WR-Periph-Syscon    (001a0400-001a04ff)
SDB:       0000ce42:e2d13d04 WR-Periph-UART      (001a0500-001a05ff)
SDB:       0000ce42:779c5443 WR-Periph-1Wire     (001a0600-001a06ff)
SDB:       0000ce42:779c5445 WR-Periph-AuxWB     (001a0700-001a07ff)
SDB: 0000ce42:00000013 WB-VIC-Int.Control  (00090000-000900ff)
SDB: UNKNOWN TYPE 0x82
SDB: UNKNOWN TYPE 0x81
@end smallexample

(The last two @t{UNKNOWN} lines are about informative structures that are
not yet dumped by @i{fmc-bus}).

The module, then supports some more parameters that are
calibration-specific. They are described in @ref{Calibration}.

@c ##########################################################################
@node Source Code Conventions
@chapter Source Code Conventions

This is a random list of conventions I use in this package

@itemize @bullet

@item All internal symbols in the driver begin with @code{fd_}
(excluding local variables like @i{i} and similar stuff). So you know
if something is local or comes from the kernel.

@item All library functions and public data begin with @code{fdelay_}.

@item The board passed as a library token (@code{struct fdelay_board})
is opaque, so the user doesn't access it.  Internally it is called
@code{userb} because @code{b} is the real one being used. If you need
to access library internals from a user file just define
@code{FDELAY_INTERNAL} before including @code{fdelay-lib.h}.

@item The driver header is called @code{fine-delay.h} while the user one
is @code{fdelay-lib.h}. The latter includes the former, which user
programs should not refer to.  Both are different from the original
implementation (@code{fdelay_lib.h}) to avoid trying to compile older
code with new headers.

@item The @i{tools} directory includes standalone tools that access ZIO
directly. Their name begins with @code{fd-raw-} (but there is a
non-fine-delay tool to generate pulses on the parallel port, which has
a different name pattern).

@item The @i{lib} directory includes example programs for the library.
Unfortunately sources of programs and library files both begin with
@code{fdelay-} -- this is an overlook of mine but I won't fix it.

@end itemize

@c ##########################################################################
@node Using the Driver Directly
@chapter Using the Driver Directly

The driver is designed as a ZIO driver that offers 1 input channel and
4 output channels. Since each output channel is independent (they do
not output at the same time) the device is modeled as 5 separate
@i{csets}.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation (ZIO is an @code{ohwr.org}
project).

@c ==========================================================================
@node The device
@section The device

The overall device includes a few device attributes and a few attributes
specific to the csets (some attributes for input and some attributes for
output).
The attributes allow to read and write the internal timing of the
card, as well as other internal parameters, documented below. Since ZIO
has no support for @i{ioctl}, all the attributes appear in @i{sysfs}.
For multi-valued attributes (like a time tag, which is more than 32
bits) the order of reading and writing is mandated by the driver
(e.g.: writing the seconds field of a time must be last, as it is the
action that fires hardware access for all current values).

The device appears in @i{/dev} as a set of char devices:

@smallexample
   spusa# ls -l /dev/zio/*
   crw------- 1 root root 249,   0 Apr 26 00:26 /dev/zio/zio-fd-0200-0-0-ctrl
   crw------- 1 root root 249,   1 Apr 26 00:26 /dev/zio/zio-fd-0200-0-0-data
   crw------- 1 root root 249,  32 Apr 26 00:26 /dev/zio/zio-fd-0200-1-0-ctrl
   crw------- 1 root root 249,  33 Apr 26 00:26 /dev/zio/zio-fd-0200-1-0-data
   crw------- 1 root root 249,  64 Apr 26 00:26 /dev/zio/zio-fd-0200-2-0-ctrl
   crw------- 1 root root 249,  65 Apr 26 00:26 /dev/zio/zio-fd-0200-2-0-data
   crw------- 1 root root 249,  96 Apr 26 00:26 /dev/zio/zio-fd-0200-3-0-ctrl
   crw------- 1 root root 249,  97 Apr 26 00:26 /dev/zio/zio-fd-0200-3-0-data
   crw------- 1 root root 249, 128 Apr 26 00:26 /dev/zio/zio-fd-0200-4-0-ctrl
   crw------- 1 root root 249, 129 Apr 26 00:26 /dev/zio/zio-fd-0200-4-0-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries the three names that have been used over time
(the newest name is shown above; the oldest didn't have the two
@code{zio} ).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.

In this drivers, @i{cset} 0 is for the input signal, and @i{csets} 1..4 are
for the output channels.

If more than one board is probed for, you'll have two or more similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0200} that follows the device name @code{zio-fd} in the
stanza above. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 2.

For remotely-controlled devices (e.g. Etherbone) the problem will need
to be solved differently.

Device (and channel) attributes can be accessed in the proper @i{sysfs}
directory. For a card in slot 0 of bus 2 (like shown above), the
directory is @i{/sys/bus/zio/devices/zio-fd-0200}:

@smallexample
   spusa# ls -Ff /sys/bus/zio/devices/zio-fd-0200/
   ./      enable           utc-l        subsystem  fd-ch1/
   ../     resolution-bits  coarse       power/     fd-ch2/
   uevent  version          command      driver     fd-ch3/
   name    utc-h            temperature  fd-input/  fd-ch4/
@end smallexample

@c ==========================================================================
@node Device Attributes
@section Device Attributes

Device-wide attributes are the three time tags (@i{utc-h}, @i{utc-l},
@i{coarse}), a read-only @i{version}, a read-only @i{temperature} 
and a write-only @i{command}.
To read device time you
should read @i{utc-h} first.  Reading @u{utc-h} will atomically read
all values from the card and store them in the software driver: when
reading @i{utc-l} and @i{coarse} you'll get such cached values.

Example:
@smallexample
   spusa# cd /sys/bus/zio/devices/zio-fd-0200/
   spusa# cat coarse coarse utc-h coarse
   75136756
   75136756
   0
   47088910
@end smallexample

To set the time, you can write the three values leaving @i{utc-h}
last: writing @i{utc-h} atomically programs the hardware:

@smallexample
   spusa# echo 10000 > coarse; echo 10000 > utc-l; echo 0 > utc-h
   spusa# cat utc-h utc-l
   0
   10003
@end smallexample

The temperature value is scaled by four bits, so you need divide it by
16 to obtain the value in degrees. In this example:

@smallexample
   spusa# cat temperature
   1129
@end smallexample

Temperature is 70.5625 degrees.

If you write 0 to @i{command}, board time will be
synchronized to the current Linux clock within one microsecond
(reading Linux time and writing to the @i{fine-delay} registers is
done with interrupts disabled, so the actual synchronization precision
depends on the speed of your CPU and PCI bus):

@smallexample
   spusa# cat utc-h utc-l; echo 0 > command; cat utc-h utc-l; date +%s
   0
   50005
   0
   1335948116
   1335948116
@end smallexample

However, please note that the times will diverge over time. Also, if
you are using White-Rabbit mode, host time is irrelevant to the board.

I chose to offer a @i{command} channel, which is opaque to the user,
because there are several commands that you may need to send to the
device, and we need to limit the number of attributes. The command numbers
are enumerated in @code{fine-delay.h} and described here below.

@c --------------------------------------------------------------------------
@node List of Commands to the Device
@subsection List of Commands to the Device

The following commands are currently supported for the @code{command}
write-only file in @i{sysfs}:

@table @code

@item 0 = FD_CMD_HOST_TIME

	Set board time equal to host time.

@item 1 = FD_CMD_WR_ENABLE

	Enable White-Rabbit mode.

@item 2 = FD_CMD_WR_DISABLE

	Disable White-Rabbit mode.

@item 3 = FD_CMD_WR_QUERY

	Tell the user the status of White-Rabbit mode. This is a hack, as
        the return value is reported using error codes. Success means
        White-Rabbit is synchronized.  @code{ENODEV} means WR mode is not supported or inactive,
        @code{EAGAIN} means it is not synchronized yet.
        The error is returned to the @i{write} system call.

@item 4 = FD_CMD_DUMP_MCP 

	Force dumping to log messages (using a plain @i{printk} the
        GPIO registers in the MCP23S17 device (fixme: is it really needed).

@item 5 = FD_CMD_PURGE_FIFO

	Empty the input fifo and reset the sequence number.

@end table

@c --------------------------------------------------------------------------
@node Reading Board Time
@subsection Reading Board Time

The program @i{fd-raw-gettime}, part of this package, allows reading
the current board time using @i{sysfs} directly:

@smallexample
   spusa# ./tools/fd-raw-gettime ; sleep 1; ./tools/fd-raw-gettime
   3303.076543536
   3304.082016080
@end smallexample

In the example above the time has never been set, so the epoch if FPGA
load time.

@b{Note:} the tool is bugged as of year 2038 because it assumes utc-h is 0.

@c --------------------------------------------------------------------------
@node Writing Board Time
@subsection Writing Board Time

The program @i{fd-raw-settime}, part of this package, allows setting
the current board time using @i{sysfs} directly:

@smallexample
   spusa# ./tools/fd-raw-settime  123; ./tools/fd-raw-gettime
   123.000541696
   spusa# ./tools/fd-raw-settime  123 500000000; ./tools/fd-raw-gettime
   123.500570096
@end smallexample

@b{Note:} the tool is bugged as of year 2038 because it assumes utc-h is 0.

No tool is there to sync the board to Linux time, because writing
0 to the @i{command} attribute is atomic by itself, but there is an
example program using the official API (see @ref{Time Management}).

@c ==========================================================================
@node The Input cset
@section The Input cset

The input cset returns fake data, with timestamp information in the
control block (the meta-information associated to data). This is
suboptimal, but it is a ``good enough'' first implementation until
time permits to refine it.

Currently, no input timestamp is collected until some process calls
the @i{read} function on the control or data char device.

In a perfect world we would have a custom @i{trigger} module that
stuffs the timestamp information directly in the proper place within
the ZIO control block.  This version of the code uses the default ZIO
trigger, which is user-driven.  In other words, data is only requested
to hardware if a user process is actually reading.  This ``software''
trigger sticks a software timestamp in the control block, so the hardware
timestamp must be provided elsewhere.

The hardware timestamp and other information is returned as @i{channel
attributes}, which you can look at using @i{zio-dump} (part of the ZIO
package) or
@i{tools/fd-raw-input} which is part of this package.

@c --------------------------------------------------------------------------
@node Input Device Attributes
@subsection Input Device Attributes

The attributes are all 32-bit unsigned values, and their meaning
is defined in @i{fine-delay.h} for libraries/applications to use them:

@example
   enum fd_zattr_in_idx {
           FD_ATTR_TDC_UTC_H,
           FD_ATTR_TDC_UTC_L,
           FD_ATTR_TDC_COARSE,
           FD_ATTR_TDC_FRAC,
           FD_ATTR_TDC_SEQ,
           FD_ATTR_TDC_CHAN,
           FD_ATTR_TDC_FLAGS,
           FD_ATTR_TDC_OFFSET,
           FD_ATTR_TDC_USER_OFF,

   }; 
   /* Names have been chosen so that 0 is the default at load time */
   #define FD_TDCF_DISABLE_INPUT	1
   #define FD_TDCF_DISABLE_TSTAMP	2
   #define FD_TDCF_TERM_50		4
@end example

The attributes are also visible in @i{/sys}, in the directory
describing the cset:

@smallexample
   spusa# ls -Ff /sys/bus/zio/devices/zio-fd-0200/fd-input/
   ./      enable           utc-l   chan         power/
   ../     current_trigger  coarse  flags        trigger/
   uevent  current_buffer   frac    offset       chan0/
   name    utc-h            seq     user-offset
@end smallexample

The timestamp-related values in this file reflect the last stamp that
has been enqueued to user space (this may be the next event to be
read by the actual reading process).

The @i{offset} attribute
is the stamping offset, in picoseconds, for the TDC channel.
The @i{user-offset} attribute, which defaults to 0 every time the
driver is loaded, is a
signed value that users can write to represent a number of picoseconds
to be added (or subtracted) to the hardware-reported stamps. This is
used to account for delays induced by cabling (range: -2ms to 2ms).

The @i{flags} attribute can be used to change three configuration
bits, defined by the respective macros. Please note that the default
at module load time is zero: some of the flags bits are inverted
over the hardware counterpart, but the @code{DISABLE} in flag names
is there to avoid potential errors.

@c --------------------------------------------------------------------------
@node Reading with zio-dump
@subsection Reading with zio-dump

This is an example read sequence using @i{zio-dump}: data must be ignored
and only the first few extended attributes are meaningful. This can
be used to see low-level details, but please note
that the programs in @code{tools/} and @code{lib/} in this package are
in general a better choice to timestamp input pulses.

@smallexample
   spusa# zio-dump /dev/zio/zio-fd-0200-0-0-*
   Ctrl: version 0.5, trigger user, dev fd, cset 0, chan 0
   Ctrl: seq 1, n 16, size 4, bits 32, flags 01000001 (little-endian)
   Ctrl: stamp 1335737285.312696982 (0)
   Device attributes:
       [...]
       Extended: 0x0000003f
       0x0 0x30 0x640f20d 0x60a 0x0 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x40 0x454b747 0x1d3 0x1 0x0 0x0 0x0
       [...]
       Extended: 0x0000003f
       0x0 0x47 0xf04c57 0x772 0x2 0x0 0x0 0x0
@end smallexample

@c --------------------------------------------------------------------------
@node Reading with fd-raw-input
@subsection Reading with fd-raw-input

The @i{tools/fd-raw-input} program, part of this package, is a low-level
program to read input events. It reads
the control devices associated to @i{fine-delay} cards, ignoring the
data devices which are known to not return useful information.
The program can receive
file names on the command line, but reads all fine-delay devices by
default -- it looks for filenames in @i{/dev} using @i{glob} patterns (also
called ``wildcards'').

This is an example run:

@smallexample
   spusa# ./tools/fd-raw-input
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001a 00b9be2b 00000bf2 00000000
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 00e7f5c2 0000097d 00000001
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 02c88901 00000035 00000002
   /dev/zio/zio-fd-0200-0-0-ctrl: 00000000 0000001b 03e23c26 000006ce 00000003
@end smallexample

The program offers a ``float'' mode, that reports floating point
time differences between two samples (this doesn't use the @i{frac} delay
value, though, but only the integer second and the coarse 8ns timer).

This is an example while listening to a software-generated 1kHz signal:

@smallexample
   spusa# ./tools/fd-raw-input -f
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.903957552 (delta   0.001007848)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.904971384 (delta   0.001013832)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.905968648 (delta   0.000997264)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.906980376 (delta   0.001011728)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1825.907997128 (delta   0.001016752)
@end smallexample

The tool reports lost events using the sequence number (attribute number 
4). This is an example using a software-generated burst with a 10us period:

@smallexample
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385815880 (delta   0.000010024)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385825832 (delta   0.000009952)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.385835720 (delta   0.000009888)
   /dev/zio/zio-fd-0200-0-0-ctrl: LOST 2770 events
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412775304 (delta   0.026939584)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412784808 (delta   0.000009504)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412794808 (delta   0.000010000)
   /dev/zio/zio-fd-0200-0-0-ctrl:    1958.412804184 (delta   0.000009376)
@end smallexample

The ``pico'' mode of the program (command line argument @code{-p}) is
used to get input time stamps with picosecond precision. In this mode
the program doesn't report the ``second'' part of the stamp. This is
an example run of the program, fed by 1kHz generated from the board
itself:

@smallexample
   spusa.root# ./tools/fd-raw-input -p | head -5
   /dev/zio/zio-fd-0800-0-0-ctrl: 642705121635
   /dev/zio/zio-fd-0800-0-0-ctrl: 643705121647 - delta 001000000012
   /dev/zio/zio-fd-0800-0-0-ctrl: 644705121656 - delta 001000000009
   /dev/zio/zio-fd-0800-0-0-ctrl: 645705121647 - delta 000999999991
   /dev/zio/zio-fd-0800-0-0-ctrl: 646705121664 - delta 001000000017
@end smallexample

If is possible, for diagnostics purposes, to run several modes
at the same time: while @code{-f} and @code{-p} disable raw/hex mode,
the equivalent options @code{-r} and @code{-h} reinstantiate it.
If the input event is reported in more than one format, the filename
is only printed once, and later lines begin with a single blank space
(you may see more blanks because they are part of normal output,
for alignment purposes).

If you are using the tool in a script, and you want to capture all the
samples in a burst and then terminate, you can specify a timeout, in
microseconds, using @t{-t}.  The timeout is only applied after the
first pulse is received.

Finally, the program uses two environment variables, if set to any value:
@code{FD_SHOW_TIME} make the tool report the time difference between
sequential reads, which is mainly useful to debug the driver workings;
@code{FD_EXPECTED_RATE} makes the tool report the difference from the
expected data rate, relative to the first sample collected:

@smallexample
   spusa.root# FD_EXPECTED_RATE=1000000000 ./tools/fd-raw-input -p | head -5
   /dev/zio/zio-fd-0800-0-0-ctrl: 139705121668
   /dev/zio/zio-fd-0800-0-0-ctrl: 140705121699 - delta 001000000031 - error  31
   /dev/zio/zio-fd-0800-0-0-ctrl: 141705121661 - delta 000999999962 - error  -7
   /dev/zio/zio-fd-0800-0-0-ctrl: 142705121671 - delta 001000000010 - error   3
   /dev/zio/zio-fd-0800-0-0-ctrl: 143705121689 - delta 001000000018 - error  21
@end smallexample

Please note that the expected rate is a 32-bit integer, so it is limited
to 4ms; moreover it is only used in ``picosecond'' mode.

@c --------------------------------------------------------------------------
@node Using fd-raw-perf
@subsection Using fd-raw-perf

The program @i{tools/fd-raw-perf} gives trivial performance figures for
a train of input pulses. It samples all input events and reports some
statistics when a burst completes (i.e., no pulse is received for at
least 300ms):

@smallexample
   spusa#  ./tools/fd-raw-perf
   59729 pulses (0 lost)
      hw: 1000000000ps (1.000000kHz) -- min 999999926 max 1000000089 delta 163
      sw: 983us (1.017294kHz) -- min 7 max 18992 delta 18985
@end smallexample

The program uses the environment variable @code{PERF_STEP}, if set, to
report information every that many seconds, even if the burst is still
running:

spusa.root# PERF_STEP=5 ./tools/fd-raw-perf
@smallexample
   4999 pulses (0 lost)
      hw: 1000000000ps (1.000000kHz) -- min 999999933 max 1000000067 delta 134
      sw: 1000us (1.000000kHz) -- min 8 max 10001 delta 9993

   4999 pulses (0 lost)
      hw: 1000000000ps (1.000000kHz) -- min 999999926 max 1000000081 delta 155
      sw: 1000us (1.000000kHz) -- min 7 max 18995 delta 18988
@end smallexample

@c --------------------------------------------------------------------------
@node Configuring the Input Channel
@subsection Configuring the Input Channel

There is no support in @i{tools/} to change channel configuration
(but see @ref{Input Configuration} for the official API).
The user is expected to write values in the @i{flags} file directly.
For example, to enable the termination resistors, write 4 to the
@i{flags} file in @i{sysfs}.

@c --------------------------------------------------------------------------
@node Pulsing from the Parallel Port
@subsection Pulsing from the Parallel Port

For my initial tests, some of which are shown above, I generated bursts
of pulses with a software
program (later I used the board itself, for a much better precision).
To do so, I connected a pin of a parallel port plugged on the PCI bus to
the input channel of the @i{fine-delay} card.

The program @i{tools/parport-burst}, part of this package, generates a
burst according to three command line parameters: the I/O port of
the data byte of the parallel port, the repeat count and the duration
of each period. This example makes 1000 pulses of 100 usec each,
using the physical address of my parallel port (if yours is part
of the motherboard, the address is @code{378}):

@example
   ./parport-burst d080 1000 100
@end example

@c ==========================================================================
@node The Output cset
@section The Output cset

The output channels need some configuration to be provided. This
is done using attributes. Attributes can either be written in
@i{sysfs} or can be passed in the control block that accompanies data.

This driver defines the sample size as 4 bytes and the trigger should
be configured for a 1-sample block (the library does it at open
time). We should aim at a zero-size data block, but this would require
a patch to ZIO, and I'd better not change version during development.

The output is configured and activated by writing a control block
with proper attributes set. Then a write to the data channel will
push the block to hardware, for it to be activated.

The driver defines the following attributes:

@example
   /* Output ZIO attributes */
   enum fd_zattr_out_idx {
           FD_ATTR_OUT_MODE = FD_ATTR_DEV__LAST,
           FD_ATTR_OUT_REP,
           /* Start (or delay) is 4 registers */
           FD_ATTR_OUT_START_H,
           FD_ATTR_OUT_START_L,
           FD_ATTR_OUT_START_COARSE,
           FD_ATTR_OUT_START_FINE,
           /* End (start + width) is 4 registers */
           FD_ATTR_OUT_END_H,
           FD_ATTR_OUT_END_L,
           FD_ATTR_OUT_END_COARSE,
           FD_ATTR_OUT_END_FINE,
           /* Delta is 3 registers */
           FD_ATTR_OUT_DELTA_L,
           FD_ATTR_OUT_DELTA_COARSE,
           FD_ATTR_OUT_DELTA_FINE,
           /* The two offsets */
           FD_ATTR_OUT_DELAY_OFF,
           FD_ATTR_OUT_USER_OFF,
           FD_ATTR_OUT__LAST,
   };
   enum fd_output_mode {
           FD_OUT_MODE_DISABLED = 0,
           FD_OUT_MODE_DELAY,
           FD_OUT_MODE_PULSE,
   };
@end example

To disable the output, you must assign 0 to the mode attribute and
other attributes are ignored.  To configure pulse or delay, all
attributes must be set to valid values.

@b{Note:} writing the output configuration (mode, rep, start, end,
delta) to @i{sysfs} is not working with this version of ZIO. And I've
been too lazy to add code to do that.  While recent developments in ZIO
introduced more complete consistency between the various places where
attributes live, with this version you can only write these attributes to
the control block.

The @i{delay-offset} attribute represents an offset that is subtracted
from the user-requested delay (@i{start} fields) when generating output
pulses. It represents internal card delays.  The value can be modified
from @i{sysfs}.

@b{Note:} the @i{delay-offset} is used for delay mode but not
for pulse-generation mode.

The @i{user-offset} attribute, which defaults to 0 at module load time, is a
signed value that users can write to represent a number of picoseconds
to be added (or subtracted) to every user-command (for both delay
and pulse generation). This is used to account for delays induced by
cabling (range: -2ms to 2ms).  The value can be modified
from @i{sysfs}.

This is the unsorted content of the @i{sysfs} directory for each
of the output csets:

@smallexample
   spusa# ls -fF /sys/bus/zio/devices/zio-fd-0200/fd-ch1
   ./               mode          end-l         user-offset
   ../              rep           end-coarse    power/
   uevent           start-h       end-fine      trigger/
   name             start-l       delta-l       chan0/
   enable           start-coarse  delta-coarse
   current_trigger  start-fine    delta-fine
   current_buffer   end-h         delay-offset
@end smallexample

As said, only @i{delay-offset} and @i{user-offset} are designed to be
read and written by the user. Additionally, @i{mode} can be read to
know whether the channel output or delay event  has triggered.
As of this version, the other attributes are not
readable nor writable in @i{sysfs} --  they are meant to be used
in the control block written to @i{/dev}.

@c --------------------------------------------------------------------------
@node Using fd-raw-output
@subsection Using fd-raw-output

The simplest way to generate output is using the tools in @code{lib/}.
You are therefore urged to skip this section and read @ref{Output
Configuration} instead.

For the bravest people, the low
level way to generate output is using @i{fd-raw-output}, part
of the @i{tools} directory of this package.  The tool writes a control
block to the ZIO control file, setting the block size to 1 32-bit
sample; it then writes 4 bytes to the data file to force output of the
attributes.

The tool acts on channel 1 (the first) by default, but uses the
environment variable @code{CHAN} if set.  All arguments on the command
line are passed directly in the attributes.  Thus, it is quite a
low-level tool. 

To help the user, any number that begins with @code{+} is added to the
current time (in seconds). It is thus recommended to set the card to follow
system time.

The following example sets card time to 0 and programs 10 pulses at
the beginning of the next second.  The pulses are 8usec long and
repeat after 16usec.  The next example runs 1s of 1kHz square wave.
For readability, numbers are grouped as @i{(mode, delay), (start --
utc-h, utc-l, coarse, frac), (stop -- utc-h, utc-l, coarse, frac),
(delta - utc-l, coarse, frac)}.

@smallexample
   spusa# ./tools/fd-raw-settime 0 0; \
          ./tools/fd-raw-output 2 10   0 1 0 0   0 1 1000 0   0 2000 0

   spusa# ./tools/fd-raw-settime 0 0; \
          ./tools/fd-raw-output 2 500   0 1 0 0   0 1 62500 0   0 125000 0
@end smallexample 

The following example sets board time to host time and programs a single
40us pulse at the beginning of the next second (note use of @code{+})

@smallexample
   spusa# echo 0 > /sys/bus/zio/devices/fd-*/command; \
          ./tools/fd-raw-output 2 0   0 +1 0 0   0 +1 5000 0 
@end smallexample 

The following example programs a pps pulse (1ms long) on channel 1
and a 1MHz square wave on channel 2, assuming board time is already
synchronized with host time:

@smallexample
   spusa# CHAN=1 ./tools/fd-raw-output 2 -1   0 +1 0 0   0 +1 125000 0  1 0 0; \
          CHAN=2 ./tools/fd-raw-output 2 -1   0 +1 0 0   0 +1 64 0   0 125 0
@end smallexample 

@c ##########################################################################
@node Using the Provided API
@chapter Using the Provided API

This chapter describes the higher level interface to the board,
designed for user applications to use.  The code lives in the @i{lib}
subdirectory of this package. The directory uses a plain Makefile (not
a Kbuild one) so it can be copied elsewhere and compiled stand-alone.
Only, it needs a copy of @code{fine-delay.h} (which it currently pulls
from the parent directory) and the ZIO headers, retrieved using the
@code{ZIO} environment variable).

@c ==========================================================================
@node Initialization and Cleanup
@section Initialization and Cleanup

The library offers the following structures and functions:

@table @code

@item struct fdelay_board;

	This is the ``opaque'' token that is being used by library clients.
        If you want to see the internals define @code{FDELAY_INTERNAL}
        and look at @i{fdelay_list.c}.

@item int fdelay_init(void);
@itemx void fdelay_exit(void);

	The former function allocates its internal data and returns
	the number of boards currently found on the system. The latter
        releases any allocated data. If @i{init} fails, it returns -1 with
        a proper @code{errno} value. If no boards are there it returns 0.
        You should not load or unload drivers between @i{init} and @i{exit}.

@item struct fdelay_board *fdelay_open(int index, int dev_id);
@item int fdelay_close(struct fdelay_board *);

	The former function opens a board and returns a token that can
        be used in subsequent calls. The latter function undoes it.
        You can refer to a board either by index or by
        @code{dev_id}. Either argument (but not both) may be -1. If both
        are different from -1 the index and dev_id must match. If a mismatch
        is found, the function return NULL with @code{EINVAL}; if either index or
        @code{dev_id} are not found, the function returns NULL with @code{ENODEV}.

@item struct fdelay_board *fdelay_open_by_lun(int lun);

	The function opens a pointer to a board, similarly to @i{fdelay_open},
        but it uses the Logical Unit Number as argument instead. The LUN
        is used internally be CERN libraries, and the function is needed
        for compatibility with the installed tool-set.  The function uses
        a symbolic link in @i{dev}, created by the local installation procedure.

@end table

The sample program @i{fdelay-list} lists the boards currently on the system,
using @i{fdelay_init}:

@smallexample
   spusa# ./lib/fdelay-list
   ./lib/fdelay-list: found 1 boards
     dev_id 0200, /dev/zio/zio-fd-0200, /sys/bus/zio/devices/zio-fd-0200
@end smallexample

@c ==========================================================================
@node Time Management
@section Time Management

These are the primitives the library offers for time management.

@table @code

@item struct fdelay_time;

	The structure has the same fields as the one in the initial
        user-space library. All but @i{utc} are unsigned 32-bit values
        whereas they were different types in the first library.

@item int fdelay_set_time(struct fdelay_board *b, struct fdelay_time *t);
@itemx int fdelay_get_time(struct fdelay_board *b, struct fdelay_time *t);

	The functions are used to set board time from a user-provided
        time, and to retrieve the current board time to user space.
        The functions return 0 on success. They only use the fields
        @i{utc} and @i{coarse} of @code{struct fdelay_time}.

@item int fdelay_set_host_time(struct fdelay_board *b);

	The function sets board time equal to host time. The precision
        should be in the order of 1 microsecond, but will drift over time.

@end table

The current API clearly lacks a function to report the offset from
board-time and system-time.

The program @i{fdelay-board-time} is a command-line front-end to the library,
to validate the library works as expected:

@smallexample
   spusa# ./lib/fdelay-board-time  25.5; ./lib/fdelay-board-time get
   25.504007360
   spusa# ./lib/fdelay-board-time  get
   34.111048968
   spusa# ./lib/fdelay-board-time  host
   spusa# ./lib/fdelay-board-time  get
   1335974946.493415600
@end smallexample

If more than one @i{fine-delay} board is found, the program will also
print to @i{stderr} how many boards it finds and which one it is using.
To select a board different from the default, you can pass
``@t{-i <index>}'' to theprogram, where the index starts from zero.

@c ==========================================================================
@node Input Configuration
@section Input Configuration

To configure the input channel for a board, the library offers the
following function and macros:

@table @code

@item int fdelay_set_config_tdc(struct fdelay_board *b, int flags);
@itemx int fdelay_get_config_tdc(struct fdelay_board *b);

	The function configures a few options in the input channel.
	The @i{flags} argument is a bit-mask of the following three
        values (note that 0 is the default at initialization time).
        The function returns -1 with @code{EINVAL} if the @i{flags}
        argument includes undefined bits.

@item FD_TDCF_DISABLE_INPUT
@itemx FD_TDCF_DISABLE_TSTAMP
@itemx FD_TDCF_TERM_50

	The first bit disables the input channel, the second disables
        acquisition of timestamps, and the last enables the 50-ohm
        termination on the input channel.

@end table

The example program @i{fdelay-term} demonstrates use of the function.
It just enables or disables the 50-ohm resistor.  The effect is
usually verifiable by hooking a scope to the input signal:


@c ==========================================================================
@node Reading Input Time-stamps
@section Reading Input Time-stamps

The library offers the following functions that deal with the input stamps:

@table @code

@item int fdelay_fread(struct fdelay_board *b, struct fdelay_time *t, int n);

	The function behaves like @i{fread}: it tries to read all samples,
        even if it implies sleeping several times.  Use it only if you are
        aware that all the expected pulses will reach you.

@item int fdelay_read(struct fdelay_board *b, struct fdelay_time *t, int n,
		       int flags);

	The function behaves like @i{read}: it will wait at most once
        and return the number of samples that it received.  The @i{flags}
        argument is used to pass 0 or @code{O_NONBLOCK}. If a non-blocking
        read is performed, the function may return -1 with @code{EAGAIN}
        if nothing is pending in the hardware FIFO.
        
@item int fdelay_fileno_tdc(struct fdelay_board *b);

	This returns the file descriptor associated to the TDC device,
        so you can @i{select} or @i{poll} before calling @i{fdelay_read}.
        If access fails (e.g., for permission problems), the functions
        returns -1 with @code{errno} properly set.

@end table

There are two example programs here: one using @i{read} and one using
@i{fread}.

Unfortunately, even if there are samples pending, @i{read}
will only return one of them, because the ZIO device will only see the
next sample slightly after returning the previous one. This is a buffering
problem with our use of ZIO. Here below there were three stamps enqueued,
1ms spaced in time:

@smallexample
   spusa# ./lib/fdelay-read 10
   ./lib/fdelay-read: reading 10 pulses in blocking mode... got 1 of them
   seq   179: time 1447.218417376 + 0ebf
   ./lib/fdelay-read: reading 10 pulses in non-blocking mode... got 1 of them
   seq   180: time 1447.219415872 + 07b5

   spusa# ./lib/fdelay-read 10
   ./lib/fdelay-read: reading 10 pulses in blocking mode... got 1 of them
   seq   181: time 1447.220418000 + 0187
   ./lib/fdelay-read: reading 10 pulses in non-blocking mode... got -1 of them
@end smallexample

This is an example with @i{fread}, where it received two bursts of 5 pulses:
the function didn't return before getting all 10 of them:

@smallexample
   spusa# ./lib/fdelay-fread 10
   ./lib/fdelay-fread: reading 10 pulses using fread... got 10 of them
   seq   182: time 1587.441758984 + 0a4f
   seq   183: time 1587.442757840 + 03b1
   seq   184: time 1587.443757712 + 08f3
   seq   185: time 1587.444757616 + 0a71
   seq   186: time 1587.445757344 + 0480
   seq   187: time 1592.530255160 + 05b7
   seq   188: time 1592.531253896 + 0173
   seq   189: time 1592.532253704 + 0db6
   seq   190: time 1592.533253672 + 0646
   seq   191: time 1592.534253336 + 0752
@end smallexample

There is no example for @i{fdelay_fileno_tdc} using @i{select}.

@c ==========================================================================
@node Output Configuration
@section Output Configuration

The library offers the following functions for output configuration:

@table @code

@item int fdelay_config_pulse(board, channel, pulse_cfg);
@itemx int fdelay_config_pulse_ps(board, channel, pulse_ps_cfg);

	The two functions configure the channel (numbered 0..3)
        for pulse or delay mode. The former function receives
        @code{struct fdelay_pulse} (with split utc/coarse/frac times)
        while the latter receives @code{struct fdelay_pulse_ps}, with
        picosecond-based time values. The functions return 0 on success, -1
        and an error code in @code{errno} in case of failure.

@item int fdelay_has_triggered(struct fdelay_board *b, int channel);

	The function returns 1 of the output channel (numbered 0..3) has
        triggered since the last configuration request, 0 otherwise.

@end table

The configuration functions receive a time configuration. The
starting time is passed as @code{struct fdelay_time}, while the
pulse end and loop period are passed using either the same structure
or a scalar number of picoseconds. These are the relevant structures:

@example
   struct fdelay_time {
           uint64_t utc;
           uint32_t coarse;    uint32_t frac;
           uint32_t seq_id;    uint32_t channel;
   };

   struct fdelay_pulse {
           int mode;           int rep;    /* -1 == infinite */
           struct fdelay_time start, end, loop;
   };

   struct fdelay_pulse_ps {
           int mode;          int rep;
           struct fdelay_time start;
           uint64_t length, period;
   };
@end example

The @code{rep} field represents the repetition count, to output a
train of pulses. The mode field is one of @code{FD_OUT_MODE_DISABLED},
@code{FD_OUT_MODE_DELAY}, @code{FD_OUT_MODE_PULSE}.

The example program to test output generation is called
@code{lib/fdelay-pulse}, and receives several arguments. The
invocation pattern is the following:

@example
   fdelay-pulse [-w] [<dev>] <mode> <ch> <rep> <t1> <t2> <t3>"
@end example

The meaning of the arguments is as follows:

@table @code
@item [-w]

	The switch requests the program to wait for the trigger to
	happen before it returns. If missing, the program returns immediately.

@item [<dev>]

	The optional device number is needed if more than one card is
        plugged in the computer. The form is @code{0200} (bus 02, slot 00).

@item <mode>

	A string: @code{disable}, @code{pulse} or @code{delay}.

@item <ch>

	The channel number: 0 through 3.

@item <rep>

	The repetition count: how many pulses to output: -1 means forever.

@item <t1>
@itemx <t2>
@itemx <t3>

	The three times specifying the pulse burst: @i{t1} is the
        starting time, @i{t2} is the pulse length and @i{t3} is the period
        of the square wave (thus, @i{t1} is absolute and the others are
        relative times.

@end table

The syntax to specify times is of the form @code{second.micro+pico},
where the @i{seconds.micro} part resembles a floating point number and
@i{pico} is scalar. This syntax has been chosen to split the decimal
part in two fields of 6 digits and ease readability. If the
@i{seconds} field begins with @code{+}, the current host utc seconds
are added to the number.

The following example programs a pps pulse (1ms long) on channel 0
and a 1MHz square wave on channel 1, assuming board time is already
synchronized with host time:

@smallexample
   spusa# ./lib/fdelay-pulse  pulse 0 -1  +2.0  0.001    1.0        ;  \
          ./lib/fdelay-pulse  pulse 1 -1  +2.0  0.0+500  0.000001
@end smallexample

This example outputs a train of pulses, 100us long
every 1ms - 10ps:

@smallexample
  ./lib/fdelay-pulse  pulse 0 -1  +2.0  0.0001 0.000999+999990
@end smallexample 

This final example uses delay functionality, requesting 5 pulses on
channel 0, 10ms long with a delay of 100ms from the input pulses
and 100ms period. At the same time channel 1 outputs 6 pulses,
10ms long with a delay of 150ms; period is again 100ms (it's something
pretty clear to looks at on the scope).

@smallexample
  ./lib/fdelay-pulse delay 0 5   0.10 0.01 0.1; \
  ./lib/fdelay-pulse delay 1 6   0.15 0.01 0.1; \
@end smallexample 

There is an additional pulse generator test program, called @code{delay-pulse-tom}.
It has different input semantics, which may be easier to understand. For instance, command:
@smallexample
  ./lib/fdelay-pulse-tom -d 0 -m pulse -o 1 -a 10s+200n -w 100n -g 1u -q 5 -t
@end smallexample 
will tell the card 0 to produce 5 100ns-wide pulses, spaced by 1 us on output 1, 
when the card's time counter hits 10s plus 200 ns. 
The @code{-t} switch tells the program to wait until the selected channel has triggered.

@code{fdelay-pulse-tom} also provides shortcuts for outputting WR-aligned 1-PPS and 10 MHz signals. The commands:
@smallexample
  ./lib/fdelay-pulse-tom -d 0 -m pulse -o 1 -1 
  ./lib/fdelay-pulse-tom -d 0 -m pulse -o 2 -p -t
@end smallexample 
Will configure the card 0 to produce 10 MHz on output 1 and 1-PPS on output 2.

@c ==========================================================================
@node White-Rabbit Configuration
@section White-Rabbit Configuration

The following functions are offered:

@table @code

@item int fdelay_wr_mode(struct fdelay_board *b, int on);

	The function receives 0 to disable WR mode or non-0 to enable it.
        It is expected to never fail if the driver is loaded.

@item int fdelay_check_wr_mode(struct fdelay_board *b);

	The function returns 0 if the WR slave is synchronized, @code{EAGAIN}
        (an integer) if it is enabled by not yet synchronized and @code{ENODEV}
        if WR-mode is currently disabled.

The @code{fdelay-board-time} test program provides two commands for controlling the card's WR operation.
In order to enable WR mode, call it with @code{wr} command parameter:
@smallexample
   spusa# ./lib/fdelay-board-time  wr
   Locking the card to WR: ...... locked!
@end smallexample

Switching back to internal timebase is done with @code{local} command:
@smallexample
   spusa# ./lib/fdelay-board-time  local
@end smallexample

@end table

@c ##########################################################################
@node Calibration
@chapter Calibration

Calibration data for a fine-delay card is stored in the I2C FMC EEPROM
device, using the SDB filesystem. Previous versions used a constant
offset of 6kB, but the calibration format was different, so no
compatibility is retained. The driver will refuse to work with cards that have
incompatible EEPROMs, these must be re-calibrated.

The driver automatically loads calibration data from the flash at
initialization time, but only uses it if its hash is valid. The
calibration data is in @code{struct fd_calib} and the on-eeprom structure
is @code{fd_calib_on_eeprom}; both are on show in @file{fine-delay.h}.

If the hash of the data structure found on EEPROM is not valid, the
driver will use the compile-time default values.  You can act on
this configuration using a number of module parameters; please note
that changing calibration data is only expected to happen at production
time.

@table @code

@item calibration_check

This integer parameter, if not zero, makes the driver dump the binary
structure of calibration data during initialization.
It is mainly a debug tool.

@item calibration_default

This option should only be used by developers. If not zero, it tells
the driver to ignore
calibration data found on the EEPROM, thus enacting a build-time
default (which is most likely wrong for any board).

@item calibration_load

This parameter is a file name, and it should only be used by developers.
The name is used to ask the @i{firmware loader}
to retrieve a file from @file{/lib/firmware}.
The data, once read, is used only
if the size is correct. The hash is regenerated by the driver. Please
remember that all values in the calibration structure are stored as big-endian.

@item calibration_save

This option should only be used by developers, and is not supported
in this release. If you are a developer and need to change the calibration,
please check the current master branch on the repository, or a later
release.
The integer parameter is used to request saving calibration data to EEPROM,
whatever values are active after the other parameters have been used.
You can thus save the compiled-in default, the content of the firmware
file just loaded, or the value you just read from EEPROM -- not useful,
but not denied either.

@end table

This package currently offers no tool to generate the binary file for
the calibration.


@c ##########################################################################
@node Known Bugs and Missing Features
@chapter Known Bugs and Missing Features

This package is still work in progress, and unfortunately the same
applies to the packages it depends on -- @i{zio} and @i{fmc-bus}.

@c ==========================================================================
@node Bugs in Related Packages
@section Bugs in Related Packages

The current package set (i.e., @i{zio}, @i{fmc-bus} and this one) has
the following known issues exposed by @i{fine-delay}:

@itemize @bullet
@item The auto-loading of @i{fmc} modules is not yet working:

@item The @i{user} trigger of ZIO is really user-driven, so the driver
can't push stuff to the buffer until asked to. Also, a related buglet
prevents to return data immediately when asked. This will be fixed,
but it currently results in the @i{read} function only returning one
sample, and an immediately-following non-blocking @i{read} will say
nothing is there, yet.

@end itemize

@c ==========================================================================
@node Bugs in This Package
@section Bugs in This Package

This is the list of known bugs and missing features over what hardware
allows:

@itemize @bullet

@item Calibration information in the EEPROM is not fixed for
endianness, so it only works on hosts of the same endianness as the
one where it has been programmed.

@end itemize

@c ==========================================================================
@node Wish List
@section Wish List

Other less important issues may be dealt with over time, but are not
urgent as I write this:

@itemize 

@item The driver should register its own ZIO trigger, or use the new
attribute for ``greedy-input'' planned in new versions of ZIO
(thank you Federico). Currently there's no buffering and reading is
slower than it could be.

@item Most example programs only use the ``first'' board in the system.

@end itemize


@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@c ==========================================================================
@node ZIO Doesn't Compile
@section ZIO Doesn't Compile

Compilation of ZIO ma fail with error like:

@smallexample
   zio-ad788x.c:180: error: implicit declaration of function "spi_async_locked"
@end smallexample

This happens because the function wasn't there in your older kernel
version, and your system is configured to enable @code{CONFIG_SPI}.

To fix, please just remove the @i{zio-ad788x} line from
@code{drivers/Makefile}.

@c ==========================================================================
@node make modules_install misbehaves
@section make modules_install misbehaves

The command @i{sudo make modules_install} may place the modules in the wrong
directory or fail with an error like:

@smallexample
   make: *** /lib/modules/2.6.37+/build: No such file or directory.
@end smallexample

This happens when you compiled by setting @code{LINUX=} and your
@i{sudo} is not propagating the environment to its child processes.
In this case, you should run this command instead

@smallexample
   sudo make modules_install  LINUX=$LINUX
@end smallexample

@c ==========================================================================
@node Version Mismatch
@section Version Mismatch

The @i{fdelay} library may report a version mismatch like this:

@example
   spusa# ./lib/fdelay-board-time  get
   fdelay_init: version mismatch, lib(1) != drv(2)
   ./lib/fdelay-board-time: fdelay_init(): Input/output error
@end example
     
This reports a difference in the way ZIO attributes are laid out, so user
space may exchange wrong data in the ZIO control block, or may try to
access inexistent files in @i{/sys}. I suggest recompiling both the kernel
driver and user space from a single release of the source package.


@c ##########################################################################
@bye

@c  LocalWords:  gnudd titlepage iftex texinfo CERN documentlanguage settitle
@c  LocalWords:  documentencoding setfilename afourpaper paragraphindent FPGA
@c  LocalWords:  setchapternewpage finalout gateware ohwr modprobe insmod cset
@c  LocalWords:  smallexample ctrl timestamp fdelay struct spusa gitorious http
@c  LocalWords:  tagname FmcDelay timestamping Timestamps perf picosecond ATTR
@c  LocalWords:  usec EEPROM sudo
